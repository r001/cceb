#!/usr/bin/env node
// Moving NODE_APP_INSTANCE aside during configuration loading
const ArgumentParser = require('argparse').ArgumentParser
const BN = require('bignumber.js')
const Eth = require("@ledgerhq/hw-app-eth").default
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid-singleton").default
const baseDir = __dirname + '/'
const chrono = require('chrono-node')
const columnify = require('columnify')
const dateFormat = require('dateformat')
const fs = require('fs')
const log4js = require('log4js')
const logger = require("@ledgerhq/logs");
const path = require('path')
const pm2 = require('pm2')
const pressAnyKey = require('press-any-key')
const {decimalToPrecision, TRUNCATE, DECIMAL_PLACES, PAD_WITH_ZERO, SIGNIFICANT_DIGITS} = require ('ccxt')
const {promisify} = require('es6-promisify')
process.chdir(baseDir)

process.env.NODE_CONFIG_DIR = (process.env.NODE_CONFIG_DIR
  ?
    process.env.NODE_CONFIG_DIR + require('path').delimiter
  :
    "")
  + baseDir + "config/" + require('path').delimiter + baseDir + "config/secrets/"

const config = require('config')
const w3 = require('./utils/web3.js')
const ut = require('./utils/util')
logger.listen(log => console.log(log.type + ": " + log.message))
BN.set({DECIMAL_PLACES: 45, ROUNDING_MODE: 1/*round down*/})

log4js.configure(
	{
		appenders: {
			out: {type: 'stdout', layout: {
				type: 'pattern',
				pattern: '%[[%d] [%p] [%f{1}#%l] -%] %m',
			},
			},
		},
		categories: {default: {appenders: ['out'], level: 'info', enableCallStack: true}},
	}
)

const log = log4js.getLogger()
log.level = config.get('loglevel')

var dust = 0.001
var args = argParse().parseArgs()
let exchange
if (['eth', 'ledger'].filter( c => c === args.subCommand).length === 0 ) {
	const exchangeType = config.get(`keys.${args.exchange}.type`)
	if (exchangeType === 'centralized') {
		exchange = ut.getExchange(args.exchange)
	}
}
if (require.main === module) {
	(async () => {
		try {
			switch (args.subCommand) {
				case 'exchange':
					switch (args.exchangeCommand) {
						case 'listorders':
							await dispListOrders(exchange, args, undefined)
							break
						case 'add':
							await dispAddOrder(exchange, args, undefined)
							break
						case 'rm':
							await removeOrder(exchange, args, undefined)
							break
						case 'rmall':
							await removeAllOrders(exchange, args, undefined)
							break
						case 'trickle':
							await dispAddTrickleOrder(exchange, args, undefined)
							break
						case 'markets':
							await dispMarkets(exchange, args)
							break
						case 'price':
							// TODO: implement dispPrice()
							// eslint-disable-next-line
							await dispPrice(exchange, args)
							break
						case 'orderbook':
							await dispOrderbook(exchange, args)
							break
						case 'withdraw':
							await withdraw(exchange, args)
							break
						case 'deposit':
							await dispDeposit(exchange, args)
							break
						case 'listbalances':
							await dispListBalances(exchange, args, null)
							break
					}
					break
				case 'eth':
					switch (args.ethCommand) {
						case 'tx':
							await dispEthTransaction(args)
							break
						case 'abi':
							await dispEthTransaction(args)
							break
						case 'source':
							await dispEthTransaction(args)
							break
						case 'send':
							await dispEthTransaction(args)
							break
						case 'address':
							await dispEthTransaction(args)
							break
						case 'import':
							await dispEthTransaction(args)
							break
						case 'maker':
							switch (args.makerCommand) {
								case 'info':
									await dispVaultInfo(args)
									break
								case 'open':
									await dispVaultOpen(args)
									break
								case 'deposit':
									await dispVaultDeposit(args)
									break
								case 'withdraw':
									await dispVaultWithdraw(args)
									break
								case 'generate':
									await dispVaultGenerate(args)
									break
								case 'payback':
									await dispVaultPayback(args)
									break
								case 'estimate':
									await dispVaultEstimate(args)
									// --Maker MKR acution commands ---
									break
								case 'auction':
									await dispFlop()
									break
								case 'tick':
									await dispTick(args)
									break
								case 'dent':
									await dispDent(args)
									break
								case 'deal':
									await dispDeal(args)
									break
								case 'flog':
									await dispFlog(args)
							} 
							break
						case 'aave':
							switch (args.aaveCommand) {
								case 'deposit':
									await dispAaveDeposit(args)
									break
								case 'withdraw':
									await dispAaveWithdraw(args)
									break
								case 'collateral':
									await dispAaveCollateral(args)
									break
								case 'borrow':
									await dispAaveBorrow(args)
									break
								case 'payback':
									await dispAavePayback(args)
									break
								case 'swaprate':
									await dispAaveSwapRate(args)
									break
								case 'rebalance':
									await dispAaveRebalance(args)
									break
								case 'liquidate':
									await dispAaveLiquidate(args)
									break
								case 'info':
									await dispAaveInfo(args)
									break
								case 'estimate':
									await dispAaveEstimate(args)
							}							
							break
						case 'curve':
							switch (args.curveCommand) {
								case 'info':
									await dispCurveInfo(args)
									break
							}
							break
					}
					break
				case 'ledger':
					switch (args.ledgerCommand) {
						case 'addresses':
							await dispLedgerAddresses(args)
							break
					}
					break
			}
		process.exit(0)
	} catch (e) {
		log.error(e)
		process.exit(1)
	}
})()
}

async function dispLedgerAddresses (args) {
	const addresses = await ledgerAddresses(args)
	Object.keys(addresses).map(key => addresses[key].map(desc => console.log(`${key}: ${desc.address} derivePath: ${desc.derivePath}`)))
}
	
async function ledgerAddresses (args) {
	switch (args.wallet) {
		case "Ethereum":
			console.log(await TransportNodeHid.list())
			// eslint-disable-next-line
			const transport = await TransportNodeHid.create();
			// eslint-disable-next-line
			const eth = new Eth(transport)

			var addressLoc = Array.from(Array(args.count).keys())
				.map(idx => idx + args.startPosition)

			var live = await addressLoc.reduce(async (acc, loc) => {
							const results = await acc
							const derivePath = `44'/60'/${loc}'/0/0`
							return [
								...results,
								{
									address: (await eth.getAddress(derivePath)).address,
									derivePath
								}
							]
					}, []
					)

			var legacy = await addressLoc.reduce(async (acc, loc) => {
							const results = await acc
							const derivePath = `44'/60'/0'/${loc}`
							return [
								...results,
								{
									address: (await eth.getAddress(derivePath)).address,
									derivePath
								}
							]
					}, []
					)

			return {live, legacy}
	default:
			throw new Error(`Wallet ${args.wallet} not implemented yet.`)
	}
}

async function dispCurveInfo (args) {
	const {claims, crv_day, sum, crv_usd, lp_usd, gauge_percent, deposit_token} = await curveInfo(args)

	var render = claims
		.map(gauge => {return {
			gauge: gauge.gauge,                                   // name of gauge
			crv: BN(gauge.token).div(10**18).toFixed(2),          // current crv balance
			crv_usd: BN(gauge.crv_usd).div(10**6).toFixed(2),     // current crv balance in usd
			crv_100k: BN(gauge.crv_100k).div(10**18).toFixed(2),  // crv daily harvest per 100k lp token (good to compare pools)
			crv_100k_f: BN(gauge.crv_100k_f).div(10**18).toFixed(2),  // crv daily harvest per 100k lp token (good to compare pools)
			crv_day: BN(gauge.crv_day).div(10**18).toFixed(2),    // crv daily harvest per current lp token deposit
			lp: BN(gauge.lp).div(10**18).toFixed(2),              // lp tokens deposited
			lp_usd: gauge.lp_usd.toFixed(2),                      // usd value of lp tokens deposited
			boost: gauge.boost.toFixed(2),                        // current boost
			boost_f: BN( gauge.boost_f).toFixed(2),               // future boost if same lp tokens would be deposited now
			d_lp_max_boost: gauge.d_lp_max_boost.div(10**18).toFixed(2),   // this much lp tokens can be deposited without loosing max boost
			gauge_percent: gauge.gauge_percent.times(100)
			.toFixed(2),                                       // this is percentage of CRV that ends up in gauge 
			deposit_usd: gauge.deposit_token.toFormat(2), // deposited USD value in gauge 
		}})
		.sort((a, b) => Number(a.crv_100k) - Number(b.crv_100k))

	render.push({
		gauge: '---',
		crv: '---',
		crv_usd: '---',
		gauge_percent: '---',
		deposit_usd: '---',
		crv_100k: '---',
		crv_100k_f: '---',
		crv_day: '---',
		lp: '---',
		lp_usd: '---',
		boost: '---',
		boost_f: '---',
		d_lp_max_boost: '---',
	})

	render.push({
		gauge: 'TOTAL',
		crv: BN(sum).div(10**18).toFixed(2),
		crv_usd: crv_usd.div(10**6).toFixed(2),
		crv_100k: '',
		crv_100k_f: '',
		crv_day: BN(crv_day).div(10**18).toFixed(2),
		lp: '',
		lp_usd: lp_usd.toFixed(2),
		boost: '',
		boost_f: '',
		d_lp_max_boost: '',
		gauge_percent: gauge_percent.toFixed(2),
		deposit_usd: deposit_token.toFormat(2),
	})

	const columns = columnify(render,
		{config: {
			gauge: {align: 'left'},
			crv: {align: 'right'},
			crv_usd: {align: 'right'},
			crv_100k: {align: 'right'},
			crv_100k_f: {align: 'right'},
			crv_day: {align: 'right'},
			sum: {align: 'right'},
			lp: {align: 'right'},
			lp_usd: {align: 'right'},
			boost: {align: 'right'},
			boost_f: {align: 'right'},
			d_lp_max_boost: {align: 'right'},
			gauge_percent: {align: 'right'},
			deposit_usd: {align: 'right'},
		}})

	console.log(columns)
}

async function curveInfo (args) {
	var fileNames = await fs.promises.readdir(baseDir + 'abi')
	fileNames = fileNames.filter(fileName => /^CRV_GAUGE_/.test(fileName) && fileName !== 'CRV_GAUGE_CONTROLLER')

	var claims = await Promise.all(fileNames.map(async fileName => {
		return { 
			gauge: fileName, 
			token: await w3.access(fileName, 'claimable_tokens', [args.from]),
			lp_free: await w3.access('CRV_LP_' + fileName.replace(/CRV_GAUGE_/, ''), 'balanceOf', [args.from]),
		}
	}
	)
	)

	claims.map(gauge => {
		BN(gauge.lp_free).gt(1) && log.error(`${gauge.gauge} has unused LP of ${BN(gauge.lp_free).toFixed()}`)
		return 0
	})

	// claims = claims.filter(gauge => gauge.token !== '0')
	const ve_crv = await w3.access('CRV_VECRV', 'balanceOf', [args.from])
	const ve_crv_total = await w3.access('CRV_VECRV', 'totalSupply')
	// const WEEK = 604800
	const rate = await w3.access('CRV', 'rate')
	const btc_usd = (await w3.access('UNISWAP_ROUTER2', 'getAmountsOut', ["1.00000000", ["WBTC", "WETH", "USDT"]]))[2]

	claims = await Promise.all(claims.map(async claim => {
		// const period = await w3.access(claim.gauge,'period')
		// const prev_week_time = await w3.access(claim.gauge,'period_timestamp',[period])
		const crv_usd = claim.token !== '0' ? (await w3.access('UNISWAP_ROUTER2', 'getAmountsOut', [claim.token, ["CRV", "WETH", "USDT"]]))[2]: 0
		const lp = await w3.access(claim.gauge, 'balanceOf', [args.from])
		const name = claim.gauge.replace(/CRV_GAUGE_/, '')
		const lp_virtual_price = await w3.access('CRV_SWAP_' + name, 'get_virtual_price')
		const lp_usd = BN(lp).times(BN(lp_virtual_price)).div(10**36)
		const lp_total = (await w3.access(claim.gauge, 'totalSupply')).replace(/\./, "")
		const lp_all = (await w3.access('CRV_LP_' + name, 'totalSupply')).replace(/\./, "")
		var deposit_token = BN(lp_all).times(BN(lp_virtual_price)).div(10**36)
		if (/.*BTC.*|.*REN.*/.test(claim.gauge)) {
			deposit_token = deposit_token.times(BN(btc_usd)).div(10**6)
		}
		const working_balances =  await w3.access(claim.gauge, 'working_balances', [args.from])
		const working_supply =  await w3.access(claim.gauge, 'working_supply')
		const gauge_relative_weight = await w3.access('CRV_GAUGE_CONTROLLER', 'gauge_relative_weight', [claim.gauge]) 
		const next_week = String(Math.floor(Date.now() / 1000 + 604800))
		const gauge_relative_weight_f = await w3.access('CRV_GAUGE_CONTROLLER', 'gauge_relative_weight', [claim.gauge, next_week]) 
		const gauge_weight = await w3.access('CRV_GAUGE_CONTROLLER', 'get_gauge_weight', [claim.gauge]) 
		const gauge_type = await w3.access('CRV_GAUGE_CONTROLLER', 'gauge_types', [claim.gauge]) 
		const type_weight = await w3.access('CRV_GAUGE_CONTROLLER', 'get_weights_sum_per_type', [gauge_type]) 
		const gauge_percent = BN(gauge_weight).div(BN(type_weight))
		const crv_day_lp = BN(rate).times(BN(gauge_relative_weight)).times(86400).div(BN(working_supply))
		const crv_day_lp_f = BN(rate).times(BN(gauge_relative_weight_f)).times(86400).div(BN(working_supply))
		const crv_100k = crv_day_lp.times(100000)
		const crv_100k_f = crv_day_lp_f.times(100000)
		const crv_day = crv_day_lp.times(BN(lp)).div(10**18)
		const boost = BN(working_balances).div(BN(lp)).times(2.5)

		const boost_f = 
			Math.min(
				Number(
					BN(lp)
					.times(0.4)
					.plus(
						BN(lp_total)
						.times(
							BN(ve_crv)
							.div( BN(ve_crv_total))
						)
						.times(0.6)
					)
					.div(BN(lp))
					.times(2.5)),
				2.5)

		const d_lp_max_boost = BN(lp_total).times(BN(ve_crv).div(BN(ve_crv_total))).minus(BN(lp))
		return {
			...claim,
			crv_usd,
			gauge_percent,
			lp,
			lp_usd,
			lp_total,
			deposit_token,
			working_balances,
			crv_day_lp, 
			crv_100k, 
			crv_100k_f, 
			crv_day,
			boost, 
			boost_f, 
			d_lp_max_boost, 
		}   
	}))

	claims = claims
		.reduce((acc, val, idx) => {
			acc.push({...val, sum: new BN(val.token).plus((acc[idx-1] && BN(acc[idx-1].sum)||'0')).toFixed()})
			return acc}, [])

	const crv_day = claims.reduce((acc, val) => val.crv_day.plus(acc), BN(0)) 
	const sum = claims[claims.length - 1]['sum']
	const crv_usd = claims.reduce((acc, val) => BN(val.crv_usd).plus(acc), BN(0))
	const lp_usd = claims.reduce((acc, val) => BN(val.lp_usd).plus(acc), BN(0))
	const gauge_percent = claims.reduce((acc, val) => BN(val.gauge_percent).plus(acc), BN(0)).times(100)
	const deposit_token = claims.reduce((acc, val) => BN(val.deposit_token).plus(acc), BN(0))
	return {claims, crv_day, sum, crv_usd, lp_usd, gauge_percent, deposit_token}
}

async function dispAaveDeposit (args) {
	console.log(await aaveDeposit(args))
}

async function getReferralCode () {
	const network = config.get('web3.network')
	return config.get(`web3.${network}.aave.referralCode`)
}

async function aaveDeposit (args) {
	const decimals = args.token === 'ETH' ? 18 : Number(await w3.decimals(args.token))
	const depositAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	const referralCode = await getReferralCode()
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	const lendingPoolCore = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPoolCore')

	const approved = 
		args.token === 'ETH' ?
		BN(10).pow(100) :
		BN(await w3.access(args.token, 'allowance', [args.from, lendingPoolCore], 'ERC20'))
	
	if (approved.lt(depositAmt)) {
		await w3.access(
			args.token,
			'approve',
			[lendingPoolCore, '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'],
			'ERC20')
	}

	await w3.access(
		lendingPool,
		'deposit',
		[
			args.token,
			depositAmt.toFixed(),
			referralCode
		],
		'AAVE_LENDING_POOL',
		args.from,
		(args.token === 'ETH' ? depositAmt : 0))

}

async function dispAaveWithdraw (args) {
	console.log(await aaveWithdraw(args))
}

async function aaveWithdraw (args) {
	const aToken = 'a' + args.token
	const decimals = Number(await w3.decimals(aToken))
	var amount
	if (args.amount.match(/ALL/i)) {
		amount = BN(await w3.access(aToken, 'balanceOf', [args.from], 'ERC20'))
	} else {
		amount = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	}
	var canWithdraw = await w3.access(aToken, 'isTransferAllowed', [args.from, amount], 'aToken')
	if (!canWithdraw) { throw new Error('Withdraw not possible. Payback all debt first!')}
	log.debug(`amount final: ${amount.toFixed()}`)
	await w3.access(aToken, 'redeem', [amount.toFixed()], 'aToken', args.from) 
}

async function dispAaveCollateral (args) {
	console.log(await aaveCollateral(args))
}

async function aaveCollateral (args) {
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	await w3.access(lendingPool, 'setUserUseReserveAsCollateral', [args.token, !args.disable], 'AAVE_LENDING_POOL', args.from)
}

async function dispAaveBorrow (args) {
	console.log(await aaveBorrow(args))
}

async function aaveBorrow (args) {
	const decimals = args.token === 'ETH' ? 18 : Number(await w3.decimals(args.token))
	const borrowAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	const interestRateMode = args.fixed ? 1 : 2
	const referralCode = await getReferralCode()
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	await w3.access(lendingPool, 'borrow', [args.token, borrowAmt, interestRateMode, referralCode], 'AAVE_LENDING_POOL', args.from)
}

async function dispAavePayback (args) {
	console.log(await aavePayback(args))
}

async function aavePayback (args) {
	
	const decimals = 
		args.token === 'ETH' ?
		18 :
		Number(await w3.decimals(args.token))

	if ( args.amount.match(/all/i)) {

		if (args.token === 'ETH') {
			var {currentBorrowBalance:paybackAmt} = await aaveInfo({...args, aaveInfoCommand: 'user'})

			paybackAmt = BN(paybackAmt).plus(BN(config.get('web3.aave.paybackExtra')).times(BN(10).pow(18))).toFixed()
		} else {
			paybackAmt = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
		}
	} else {

		paybackAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue().toFixed()
	
	}
	
	const lendingPoolCore = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPoolCore')
	
	const approved = args.token === 'ETH' ?
		BN(10).pow(100) :
		BN(await w3.access(
			args.token,
			'allowance',
			[args.from, lendingPoolCore],
			'ERC20'
		))
	
	if (approved.lt(paybackAmt)) {
		await w3.access(
			args.token,
			'approve',
			[lendingPoolCore, '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'],
			'ERC20'
		)
	}
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
	lendingPool,
		'repay',
		[
			args.token,
			paybackAmt,
			args.for ? args.for : args.from
		],
		'AAVE_LENDING_POOL',
		args.from,
		(args.token === 'ETH' ? paybackAmt : 0) )
}

async function dispAaveSwapRate (args) {
	console.log(await aaveSwapRate(args))
}

async function aaveSwapRate (args) {
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
		lendingPool,
		'swapBorrowRateMode',
		[args.token],
		'AAVE_LENDING_POOL',
		args.from
	)
}

async function dispAaveRebalance (args) {
	console.log(await aaveRebalance(args))
}

async function aaveRebalance (args) {
	
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
		lendingPool,
		'rebalanceStableBorrowRate',
		[args.token, args.for ? args.for : args.from],
		'AAVE_LENDING_POOL',
		args.from
	)
}

async function dispAaveLiquidate (args) {
	console.log(await aaveLiquidate(args))
}

async function aaveLiquidate (args) { //TODO: implement

	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	
	await w3.access(
		lendingPool,
		'liquidationCall', 
		[
			args.token, 
			args.for ? args.for : args.from
		],
		'AAVE_LENDING_POOL',
		args.from)//TODO: finish arguments
}

async function dispAaveInfo (args) {
	console.log(await aaveInfo(args))
}

async function aaveInfo (args) {
	const lendingPool = await w3.access('AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	
	if (args.aaveInfoCommand === 'reserve') {

		var configdata =  await w3.access(
			lendingPool,
			'getReserveConfigurationData',
			[args.token],
			'AAVE_LENDING_POOL'
		)
	
		var configdata1 = await w3.access(lendingPool, 'getReserveData', [args.token], 'AAVE_LENDING_POOL')	

		return {...configdata, ...configdata1}
	
	}	else if (args.aaveInfoCommand === 'account') {
		
		return await w3.access(lendingPool, 'getUserAccountData', [args.from], 'AAVE_LENDING_POOL')		
	
	}	else if (args.aaveInfoCommand === 'user') {
	
		return await w3.access(lendingPool, 'getUserReserveData', [args.token, args.from], 'AAVE_LENDING_POOL')		
	}
}

async function dispAaveEstimate (args) {
	console.log(await aaveEstimate(args))
}

async function aaveEstimate () {
}

//---------------------
async function dispVaultEstimate () {
	console.log((await vaultEstimate()).toString())
}

async function vaultEstimate () {
	var gas = 739549
	return await estimateGasCost(gas)
}

async function dispVaultPayback (args) {
	console.log(await vaultPayback(args))
}

async function vaultPayback (args) {
	if (args.estimate) {
		var gas = 159676
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	var {vaultAddr, vaultTypeHex, daiNormalized} = await getUrnParams(vaultId, args.type)

	var ilk = await w3.access('MCD_VAT', 'ilks', [vaultTypeHex]) 
	var rate = BN(ilk.rate)
	log.debug(`rate: ${rate}`)
	
	var daiVault = BN(await w3.access('MCD_VAT', 'dai', [vaultAddr]))
	log.debug(`dai in Vault: ${daiVault.toFixed()}`)
	const daiBalance = BN(await w3.access('MCD_DAI', 'balanceOf', [args.from], 'ERC20'))
	var daiVaultNormalizedWad = daiVault.div(rate).integerValue()
	log.debug(`dai in Vaultnormalized: ${daiVaultNormalizedWad.toFixed()}`)
	var paybackWad = BN(args.amount).times(BN(10).pow(18)).integerValue()
	log.debug(`paybackWad(before leftover payback): ${paybackWad.toFixed()}`)
	paybackWad = paybackWad.minus(daiVault.div(BN(10).pow(27)).integerValue())
	log.debug(`paybackWad(after leftover payback): ${paybackWad.toFixed()}`)
	paybackWad = BN.min(paybackWad, daiNormalized.times(rate).div(BN(10).pow(27)).integerValue().plus(1), daiBalance)
	log.debug(`paybackWad(after considering actual dai debt, and balance): ${paybackWad.toFixed()}`)
	const paybackNormalizedWad = paybackWad.times(BN(10).pow(27)).div(rate).integerValue()

	log.debug(`paybackNormalizedWad: ${paybackNormalizedWad}`)
	const approvedDai = BN(await w3.access('MCD_DAI', 'allowance', [args.from, 'MCD_JOIN_DAI'], 'ERC20'))
	if (approvedDai.lt(paybackWad)) {
		await w3.access('MCD_DAI', 'approve', ['MCD_JOIN_DAI', '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'], 'ERC20', args.from)
	}
	if (paybackWad.gt(0)) {
		await w3.access('MCD_JOIN_DAI', 'join', [vaultAddr, paybackWad.toFixed()], null, args.from)
	}
	
	daiVault = BN(await w3.access('MCD_VAT', 'dai', [vaultAddr])).div(BN(10).pow(27))
	ilk = await w3.access('MCD_VAT', 'ilks', [vaultTypeHex]) 
	rate = BN(ilk.rate)
	log.debug(`rate: ${rate}`)
	daiVaultNormalizedWad = daiVault.div(rate).integerValue()
	await w3.access('MCD_CDP_MANAGER', 'frob', [vaultId, '0', daiVaultNormalizedWad], null, args.from) //FIXME: withdraw collateral too
}

async function dispVaultGenerate (args) {
	console.log(await vaultGenerate(args))
}

async function vaultGenerate (args) {
	w3.web3.eth.handleRevert = true
	if (args.estimate) {
		var gas = 208114
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const vaultAddr = await w3.access('MCD_CDP_MANAGER', 'urns', [vaultId])
	var ilk = await w3.access('MCD_VAT', 'ilks', [vaultTypeHex]) 
	var rate = new BN(ilk.rate)
	var daiToGenerate = BN(args.amount).times(BN(10).pow(45)).integerValue()
	log.debug(`DaiToGenerate: ${daiToGenerate}`)
	var daiAtVault = BN(await w3.access('MCD_VAT', 'dai', [vaultAddr]))
	log.debug(`daiAtVault: ${daiAtVault}`)
	var daiAtFrom = BN(await w3.access('MCD_VAT', 'dai', [args.from]))
	var daiTotal = daiAtVault.plus(daiAtFrom)
	log.debug(`daiAtFrom: ${daiAtFrom}`)
	var daiToFrobWad = (daiTotal.lt(daiToGenerate) ? daiToGenerate.minus(daiTotal) : BN(0)).div(rate).integerValue()
	log.debug(`DaiToFrobWad: ${daiToFrobWad}`)
	if (!daiToFrobWad.eq(BN(0))) {
		await w3.access('MCD_CDP_MANAGER', 'frob', [vaultId, 0, daiToFrobWad.toFixed()], null, args.from)
		daiAtVault = BN(await w3.access('MCD_VAT', 'dai', [vaultAddr]))
		daiTotal = daiAtVault.plus(daiAtFrom)
	}

	daiToGenerate = BN.min(daiToGenerate, daiTotal)
	
	await w3.access('MCD_CDP_MANAGER', 'move', [vaultId, args.from, daiToGenerate.minus(daiAtFrom).integerValue().toFixed()], null, args.from)

	const joinEnabled = await w3.access('MCD_VAT', 'can', [args.from, 'MCD_JOIN_DAI'])
	
	if (Number(joinEnabled) === 0) {
		await w3.access('MCD_VAT', 'hope', ['MCD_JOIN_DAI'], null, args.from)
	}

	await w3.access('MCD_JOIN_DAI', 'exit', [args.from, daiToGenerate.div(BN(10).pow(27)).integerValue().toFixed()], null, args.from)
}

async function dispVaultWithdraw (args) {
	await vaultWithDraw(args)
}

async function vaultWithDraw (args) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var collCoin = args.type.replace(/-.*/, '')
	if (args.estimate) {
		var gas = 225226
		if (collCoin === 'ETH') gas += 38169
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	if (collCoin === 'ETH') collCoin = 'WETH'
	const joinContract = 'MCD_JOIN_' + args.type.replace(/-/, "_")
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const decimals = Number(await w3.decimals(collCoin))
	var withdrawAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	var withdrawAmtWad = BN(args.amount).times(BN(10).pow(18)).integerValue()
	
	const vltInfo = await vaultInfo(args)
	const vault = vltInfo.find(vlt => vlt.vaultId.eq(vaultId))
	if (vault.collateralToWithdraw.lt(args.amount)) {
		throw Error(`You can't withdraw more than ${vault.collateralToWithdraw}. Or pay back some DAI first!`)
	}
	if (vault.unlockedCollateral.lt(args.amount)) {
		const freeCollateral = vault.unlockedCollateral.minus(args.amount).times(BN(10).pow(18)).integerValue()
		await w3.access('MCD_CDP_MANAGER', 'frob', [vaultId, freeCollateral.toFixed(), 0], null, args.from) //FIXME: allow to payback dai
	}

	await w3.access('MCD_CDP_MANAGER', 'flux', [vaultId, args.from, withdrawAmtWad.toFixed()],
		null, args.from, null, null, null, ['uint256', 'address', 'uint256'])
	
	await w3.access(joinContract, 'exit', [args.from, withdrawAmt.toFixed()], null, args.from)
	
	if (collCoin === 'WETH') {
		await w3.access('WETH', 'withdraw', [withdrawAmt.toFixed()], null, args.from)
	}
}

async function dispVaultDeposit (args) {
	console.log(await vaultDeposit(args))
}

async function vaultDeposit (args) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var collCoin = args.type.replace(/-.*/, '')
	if (args.estimate) {
		var gas = 146533
		if (collCoin === 'ETH') gas += 43766
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	if (collCoin === 'ETH') {
		collCoin = 'WETH'
		await w3.access('WETH', 'deposit', [], null, args.from, BN(args.amount).times(BN(10).pow(18)).integerValue().toFixed())
	}
	const joinContract = 'MCD_JOIN_' + args.type.replace(/-/, "_")
	const decimals = Number(await w3.decimals(collCoin))
		var allowance = BN(await w3.access(collCoin, 'allowance', [args.from, joinContract]))
		if (allowance.div(BN(10).pow(decimals)).lt(BN(args.amount))) {
			//if allowance less than amount to deposit
			log.info("approve infinite")

			await w3.access(
				collCoin, 
				'approve', 
				[
					joinContract,
					'0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
				],
				null,
				args.from)
		}
	var balance = BN(await w3.access(collCoin, 'balanceOf', [args.from]))
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const vaultAddr = await w3.access('MCD_CDP_MANAGER', 'urns', [vaultId])
	var depositAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	if (depositAmt.gt(balance)) {
		depositAmt = balance
		log.warn("Deposit truncated to: " + balance.div(BN(10).pow(decimals)).integerValue().toFixed())
	}

	log.info(`joincontract: ${joinContract} vaultAddr: ${vaultAddr} depositamt: ${depositAmt.toFixed()}`)
	await w3.access(joinContract, 'join', [vaultAddr, depositAmt.toFixed()], null, args.from)
	const depositInt = await w3.web3.eth.abi.encodeParameter('int', depositAmt.toFixed())
		var ilk = await w3.access('MCD_VAT', 'ilks', [vaultTypeHex], null, args.from) 
		var rate = new BN(ilk.rate)
	const drawDaiInt = await w3.web3.eth.abi.encodeParameter('int', BN(args.draw).times(BN(10).pow(18+27)).div(rate).integerValue().toFixed())

	await w3.access('MCD_CDP_MANAGER', 'frob', [vaultId, depositInt, drawDaiInt], null, args.from)
}

async function dispVaultOpen (args) {
	console.log(await vaultOpen(args))
}

async function estimateGasCost (gas) {
	var price = await getPriceInOtherCurrency('coinbasepro', 'ETH', 'USD')
	var gasPrice = BN(await w3.getGasPrice())
	const total = gasPrice.times(price).times(gas).div(BN(10).pow(18)).toFixed()
	return total
}

async function vaultOpen (args) {
	if (args.estimate) {
		console.log(await estimateGasCost(229642))
		process.exit(0)
	}

	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	await w3.access('MCD_CDP_MANAGER', 'open', [vaultTypeHex, args.from], null, args.from)
	return await w3.access('MCD_CDP_MANAGER', 'last', [args.from])
}

async function dispVaultInfo (args) {
	// get dai debt from vat contract
	const vltInfo = await vaultInfo(args)
	const collCoin = args.type.replace(/-.*/, '')

	vltInfo.map(vault => console.log(
		"id:" + vault.vaultId.toFixed() +
		"\nproxy: " + (vault.proxyUsed ? "true" : "false") +
		`\nfrom: ${vault.fromAddr}\
		\nvault: ${vault.vaultAddr}\
		\ndeposit: ${vault.deposit.toFixed()} ${collCoin}\
		\ndebt: ${vault.debt.toFixed()}\
		\ndaiToGenerate: ${vault.daiToGenerate.toFixed()}\
		\ncollateralToWithdraw: ${vault.collateralToWithdraw.toFixed()}\
		\nliquidationRatio: ${vault.liquidationRatio.toFixed()}\
		\nfeed: ${vault.priceFeedAddress}`
	))
}

async function getVaultId (from, vault, type) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(type).toString('hex'))
	// check if cdp is registered with proxy
	var proxyAddress = await w3.access( 'MCD_PROXY_REGISTRY', 'proxies', [from])
	var fromAddress = parseInt(proxyAddress) === 0 ? from : proxyAddress

	log.info(`fromAddress: ${fromAddress}, type: ${typeof fromAddress}`)
	
	var vaultId = vault !== 0 ? vault : await w3.access('MCD_CDP_MANAGER', 'last', [fromAddress])
	log.debug({vaultId})
	if (vaultTypeHex) {
		var vaultTypeHexCurr = await w3.access('MCD_CDP_MANAGER', 'ilks', [vaultId])
		log.debug({vaultTypeHexCurr, vaultTypeHex})
		while (vaultTypeHexCurr.toString("hex") !== vaultTypeHex.toString("hex") && vaultId !== 0) {
			if (vault !== 0) throw new Error('Vault id and type mismatch.')
			vaultId =  Number((await w3.access('MCD_CDP_MANAGER', 'list', [vaultId])).prev)
			log.debug({vaultId})
			if (vaultId !== 0) {
				vaultTypeHexCurr = await w3.access('MCD_CDP_MANAGER', 'ilks', [vaultId])
				log.debug({vaultTypeHexCurr})
			}
		}
		if (vaultTypeHexCurr !== vaultTypeHex) throw new Error('Vault type not opened yet. Pls open first!')
	}
	return {proxyAddress, fromAddress, vaultId}
}

async function getUrnParams (vaultId, type) {
	const vaultAddr = await w3.access('MCD_CDP_MANAGER', 'urns', [vaultId])

	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(type).toString('hex'))
	log.info('VaultTypeHex: ' + vaultTypeHex)
	var urn = await w3.access('MCD_VAT', 'urns', [vaultTypeHex, vaultAddr])
	var daiNormalized = BN(urn.art)
	var lockedCollateral = BN(urn.ink)
	var unlockedCollateral = BN(await w3.access('MCD_VAT', 'gem', [vaultTypeHex, vaultAddr]))
	log.info('Dai(normalized) in vault: ' + daiNormalized.toFixed())
	return {vaultAddr, vaultTypeHex, daiNormalized, lockedCollateral, unlockedCollateral}
}

async function vaultInfo (args) {
	var vaults = []
	var {proxyAddress, fromAddress, vaultId} = await getVaultId(args.from, args.vault, args.type)

	var first = true
	while (first || args.vault !== 0) {
		first = false
		log.info("args.vault: " + typeof args.vault)
		log.info(`vaultId: ${vaultId}`)
		console.log(vaultId)
		if (Number(vaultId) === 0) break

		var {vaultAddr, vaultTypeHex, daiNormalized, lockedCollateral, unlockedCollateral} = await getUrnParams(vaultId, args.type)
		//get current rate from vat contract
		var ilk = await w3.access('MCD_VAT', 'ilks', [vaultTypeHex]) 
		var rate = new BN(ilk.rate)
		var spot = new BN(ilk.spot)
		log.info('Rate of ' + args.type +' : ' + rate.div(10**27).toFixed())

		var spotIlk = await w3.access('MCD_SPOT', 'ilks', [vaultTypeHex])
		const priceFeed = spotIlk.pip
		const liquidationRatio = BN(spotIlk.mat)

		const daiDebt = daiNormalized.times(rate).div(BN(10).pow(18 + 27))

		vaults.push({
			vaultId: BN(vaultId),
			proxyUsed: fromAddress === proxyAddress,
			fromAddr: await w3.getAddress(fromAddress),
			vaultAddr: vaultAddr,
			deposit: lockedCollateral.plus(unlockedCollateral).div(BN(10).pow(18)),
			debt: daiDebt,
			daiToGenerate: spot.times(lockedCollateral.plus(unlockedCollateral)).div(BN(10).pow(27+18)).minus(daiDebt),
			lockedCollateral: lockedCollateral.div(BN(10).pow(18)),
			unlockedCollateral: unlockedCollateral.div(BN(10).pow(18)),
			collateralToWithdraw: lockedCollateral.plus(unlockedCollateral).div(BN(10).pow(18)).minus(daiDebt.div(spot.div(BN(10).pow(27)))),
			liquidationRatio: liquidationRatio.div(BN(10).pow(27)),
			priceFeedAddress: priceFeed,
		})

		vaultId = args.vault !== 0 ? args.vault : (await w3.access('MCD_CDP_MANAGER', 'list', [vaultId])).prev
	}
	return vaults
}

async function dispFlog (args) {
	console.log(await getFlog(args))
}

async function getFlog (args) {

	const logs = await w3.web3.eth.getPastLogs(
		{
			fromBlock: args.from_block,
			toBlock:   args.to_block,
			address: await w3.getAddress(args.contract),
			topics: [
				'0x697efb7800000000000000000000000000000000000000000000000000000000'
			]
		}
	)

	var era
	var log
	var sinB
	var amt = args.amount 
	const rad = new BN('1e45')
	if (!logs || logs.length === 0) {
		console.log('no events')
		process.exit(0)
	} else {
		for (var index = 0; index < logs.length && amt >= 0; index++) {
			log = logs[index]    
			var block  = await w3.web3.eth.getBlock(log.blockNumber)
			era = block.timestamp

			sinB = await w3.access(
						'MCD_VOW',
						'sin',
						[new BN(era).toFixed()],
						null, // args.abi,
						args.from, // args.from,
						null, // args.value,
						null, // args.gaslimit,
						null  // args.gasprice
						)

		const sin = Number(new BN(sinB).div(rad))
		const tab = Number(new BN(log.topics[2]).div(rad).toString())
		amt -= Math.min(sin, tab) 

		if (sin > 0) 
			await w3.access('MCD_VOW', 'flog', [era], null, args.from)

		const d = new Date(era * 1000)
		const date = dateFormat(d, 'yy-mm-dd HH:MM:ss') 
		console.log(`blk: ${log.blockNumber}, ${date}, amt: ${amt.toFixed(2)}, sin: ${sin.toFixed(2)}, tab: ${tab.toFixed(2)},\ntx: ${log.transactionHash},\nminer: ${block.miner}\n `)
		}
	}
	return ''
}

async function dispFlop () {
	console.log(await getFlop())
}

async function getFlop () {
	return await w3.access(
					'MCD_VOW',
					'flop',
					[],
					null, // args.abi,
					args.from, // args.from,
					null, // args.value,
					null, // args.gaslimit,
					null  // args.gasprice
	)
}

async function dispTick (args) {
	console.log(await getTick(args))
}

async function getTick (args) {
	return await w3.access(
					'MCD_FLOP',
					'tick',
					[args.id],
					null, // args.abi,
					args.from, // args.from,
					null, // args.value,
					null, // args.gaslimit,
					null  // args.gasprice
	)
}

async function dispDent (args) {
	console.log(await getDent(args))
}

async function getDent (args) {
	var lot
	var beg
	if (!args.amount) {
	const bids = await w3.access(
					'MCD_FLOP',
					'bids',
					[
						args.id
					],
					null,
					args.from)

		log.info(bids)
		lot = bids.lot
		beg = Number(new BN(await w3.access('MCD_FLOP', 'beg', [])).div(10**18))

		var Bignumber = BN.clone({ 
			DECIMAL_PLACES: 0,
			ROUNDING_MODE: 0})

		lot = new Bignumber(lot).times(10**18).div(beg)
	} else {
		lot = args.amount
	}
	
	return await w3.access(
					'MCD_FLOP',
					'dent',
					[
					args.id,
					lot,
					new BN(await w3.access('MCD_FLOP', 'bid', [])).toFixed(),
					],
					null, // args.abi,
					args.from, // args.from,
					null, // args.value,
					null, // args.gaslimit,
					null  // args.gasprice
	)
}

async function dispDeal (args) {
	console.log(await getDeal(args))
}

async function getDeal (args) {
	return await w3.access(
					'MCD_flop',
					'deal',
					[args.id],
					null, // args.abi,
					args.from, // args.from,
					null, // args.value,
					null, // args.gaslimit,
					null  // args.gasprice
	)
}

async function dispEthTransaction (args) {
	if (args.ethCommand === 'source') {
		console.log(await w3.getSourceCode(args.contractName))
		return
	}
	let disp = await getEthTransaction(args)
	var decimals = 18
	if ((await w3.getAddressType(args.contract)).type === 'token' &&
		['balanceOf', 'totalSupply', 'allowance'].includes(args.func)) {
		decimals = await w3.decimals(args.contract)
	}
		
	if (disp && disp.map) {
		await Promise.all(disp.map(async (func) => console.log(
			func.match && func.match(/^0x[A-Fa-f0-9]{40}$/i) ?
			await w3.getAddressName(func) :
			await toDec(func))))
	} else {
		if (disp !== null || typeof disp !== 'undefined' || disp === '') {
			if (typeof disp === 'object') {
				disp = JSON.stringify(disp)
			} else {
				disp = String(disp)
			}

			disp = (await Promise.all(
				disp.split && disp.split(/\n/)
				.map(
					async (line) => 
					line.match(/^0x[A-Fa-f0-9]{40}$/i) && !args.contr  ?
					await w3.getAddressName(line) :
					await toDec(disp, decimals))
			)).join("\n")

			console.log(disp)
		}
	}
	return
}

async function toDec (str, decimals) {
	if (typeof decimals === 'undefined' || decimals === null) decimals = 18
	log.debug(`decimals: ${decimals}`)
	if (String(str).match(/^[-+0-9]+$/)) {
		// return BN(str).div(BN(10).pow(decimals || 18)).toFixed()
		str.padStart(decimals + 1, '0')
		return str.slice(0, -(decimals)) +
			'.' +
			'000000000000000000000000000000000000'.slice(0, Math.max(decimals - str.length, 0)) +
			str.slice(-decimals)	
	} else {
		return str
	}
}

async function calcValue (from, balanceExpr) {
	var balance = BN(await w3.access('ETH', 'balanceOf', from)).div(BN(10).pow(18)).toFixed()
	return ut.evalExpr('max', balance, balanceExpr, true)
}

async function getEthTransaction (args) {
	
	if (args.ethCommand === 'import') {
		return await w3.importAddress(args)
	}

	if (args.ethCommand === 'address') {
		if (args.contr.match(/^0x[A-Fa-f0-9]{40}$/i)) {
			return await w3.getAddressName(args.contr)
		} else {
			return await w3.getAddress(args.contr)
		}
	}	
	
	if (args.ethCommand === 'send') {
		const tx = JSON.parse(args.txjson)
		return await w3.broadcastTx(
			tx.from,
			tx.to,
			tx.data,
			tx.value,
			tx.gasLimit,
			tx.gasPrice,
			tx.nonce,
			args.signature
		)
	}

	if (args.ls || args.ls === '' || args.ethCommand === 'abi') {
		
		args.ls = args.ls === '' ? '.*' : args.ls
		return await w3.getAbiFunctions(args.abi || args.contract, args.ls)
	
	}

	if (args.contract === 'ETH' || args.contract.match(/0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee/i)) {
		
		log.debug('eth transfer')
		log.debug(`args.func: ${args.func}`)
		log.debug(`args.args: ${JSON.stringify(args.args)}`)

		if (args.func.match(/transfer/i) && args.args[1].match(/max/i)) {
			
			log.debug('eth transfer')
			args.args[1] = await calcValue(args.from, args.args[1])
			log.debug(`value to send: ${args.args[1]}`)
		
		} else if (args.func.match(/^transferFrom$/i) && args.args[2].match(/max/i)) {
		
			log.debug('eth transferFrom')
			args.args[2] = await calcValue(args.args[0], args.args[2])
			log.debug(`value to send: ${args.args[2]}`)
		}
	}

	//handle array arguments
	args.args = args.args.map(
		arg => arg.match(/^\s*\[.*]\s*$/) ?
		Array.from(JSON.parse(arg)) :
		arg 
	)

	log.debug('args.args: '+JSON.stringify(args.args))

	return await w3.access(
		args.contract,
		args.func,
		args.args,
		args.abi,
		args.from,
		args.value,
		args.gaslimit,
		args.gasprice)
}

// TODO: implement background order creation
async function startProc (args) {
	const connect = promisify(pm2.connect)
	const start = promisify(pm2.start)
	// eslint-disable-next-line
	const stop = promisify(pm2.stop)
	const list = promisify(pm2.list)
	// eslint-disable-next-line
	const readFile = promisify(fs.readFile)
	// eslint-disable-next-line
	const writeFile = promisify(fs.writeFile)
	await connect()

	var procName = path.basename(__filename) + '-' + args.subCommand
	const listPm2 = await list()
	while (listPm2.findIndex(desc => desc.name === procName) !== -1) {
		procName += 'I'
	}

	const proc = await start({
		script: procName,
		options: {
			name: procName,
			args: ['--pm2'].concat(process.argv),
		},

	})

	pm2.disconnect()
	return proc
}

// TODO: implement background order creation
// eslint-disable-next-line
async function startFork (exchange, args) {
process.env.pm_id
}

async function dispAddTrickleOrder (exchange, args) {
  var order
  var totalAmount = args.amount
  var sleepMs
  const market = exchange && exchange.markets && exchange.markets[args.pair]
  while (totalAmount > 0) {

    log.info(`Current total amount: ${totalAmount}`)
    args.amount = Math.min(args.batchSize + (args.batchSizeVariance ? args.batchSizeVariance : 0) * (1 - Math.random()), totalAmount)

    args.amount = decimalToPrecision(
      args.amount,
      TRUNCATE,
      args.aPrecision || (market && market.precision.amount) || 5,
      exchange && exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    )

    log.info(`Current order amount: ${args.amount}`)
    try {
      order = await addOrder(exchange, args)
      log.info(order.id)
      if (order.id !== 'skipped-order') {
        totalAmount -= args.amount
      }
    } catch (e) {
      log.error(e)
    }
    if (order.id === 'skipped-order') {
      sleepMs = args.batchRetrySec * 1000
    } else {

    sleepMs = Math.floor(1000 * 
				(
					args.batchTime +
					(
						args.batchTimeVariance 
						? 
							args.batchTimeVariance
						: 0
					) * 
					(
						1 -
						Math.random()
					)
				)
			)
		}
    log.info(`Sleep ${sleepMs / 1000} seconds.`)
    await sleep(sleepMs)
  }
}

function sleep (ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

async function dispOrderbook (exchange, args) {
  const orderbook = await getOrderbook(exchange, args)
  let cumulativeSum = 0
  const market = exchange.markets[args.pair]
  const asks = orderbook.asks
  const bids = orderbook.bids
  var priceCurrency = 1
  if (args.currency) {
    priceCurrency = await getPriceInOtherCurrency(
      args.otherExchange,
      args.pair.replace(/.*\//, ''),
      args.currency
    )
  }
  if (args.limit && args.limit < asks.length) asks.length = args.limit
  if (args.limit && args.limit < bids.length) bids.length = args.limit

  var orderColumns = [{price: '---', amount: '---', cumsum: '---'}]

  orderColumns = orderColumns.concat(asks.map(order => [
    decimalToPrecision(
      order[0] * priceCurrency,
      TRUNCATE,
      args.pPrecision || market.precision.price || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      cumulativeSum += order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
  ])
    .reverse()
    .map(order => { return {price: order[0], amount: order[1], cumsum: order[2]} }))

  orderColumns.push({price: '---', amount: '---', cumsum: '---'})
  cumulativeSum = 0

  orderColumns = orderColumns.concat(bids.map(order => [
    decimalToPrecision(
      order[0] * priceCurrency,
      TRUNCATE,
      args.pPrecision || market.precision.price || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      cumulativeSum += order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
  ])
    .map(order => { return {price: order[0], amount: order[1], cumsum: order[2]} }))

  const columns = columnify(orderColumns, {align: 'right'})
  console.log(columns)
}

async function getPriceInOtherCurrency (exchangeName, baseToken, quoteToken) {
  const exchange1 = ut.getExchange(exchangeName)
  const orderbook = await getOrderbook(exchange1, {limit: 5, pair: baseToken + '/' + quoteToken})
  return orderbook.asks[0][0]
}

async function getOrderbook (exchange, args) {
  const limit = args.limit ? args.limit : undefined
  return await exchange.fetchOrderBook(args.pair, limit)
}

async function dispMarkets (exchange, args) {
  console.dir(JSON.stringify(await getMarkets(exchange, args)))
}

async function getMarkets (exchange) {
  return await exchange.loadMarkets()
}

async function removeAllOrders (exchange, args) {
  const orders = await listOrders(exchange, args)
  orders.map(async (order) => await removeOrder(exchange, {order: order.id, symbol: order.symbol}))
  return
}

async function removeOrder (exchange, args) {
  var symbol
  if (typeof args.symbol !== 'undefined') {
    symbol = args.symbol
  } else { 
    const orders = await listOrders(exchange, args)
    const order = orders.find(order => order.id === args.order)
    if (typeof order !== 'undefined') {
      symbol = order['symbol']
    } else {
      throw new Error('Order id ' + args.order + ' does not exist.')
    }
  }
  console.log(args.order, symbol)
  return await exchange.cancelOrder(String(args.order), String(symbol), [])
}

async function dispAddOrder (exchange, args) {
  const order = await addOrder(exchange, args)
  console.log(order.id)
}

async function addOrder (exchange, args) {
  if ((typeof exchange !== 'undefined') && exchange.id === 'okex') {
    exchange.options['createMarketBuyOrderRequiresPrice'] = false
	}
  var amount = args.amount
  const buy = args.side === 'buy'

  // disregard price data if args.type is market
  var price = args.type === 'market' ? undefined : args.price
  args.price = price

  if (!Object.keys(config.get('keys')).includes(args.exchange)) {
    throw new Error('Exchange "' + args.exchange + '" not found in config ./config/default.yaml.')
  }
  const exchangeType = config.get(`keys.${args.exchange}.type`)
  switch (exchangeType) {
    case 'centralized':
      return await addOrderCentralized(exchange, args, amount, buy, price)
    case 'kyber':
      return await addOrderKyber(args, amount, buy, price)
    case 'uniswap':
      return await addOrderUniswap(args, amount, buy, price)
  }
}

async function addOrderUniswap (args, amount, buy) {

  if (args.type === 'limit') {
    throw new Error(`Limit orders not supported (yet).`)
  }
  const sellToken = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
  log.info(`Sell token: ${sellToken}`)

  const buyToken = buy ? args.pair.replace(/\/.*/, '') : args.pair.replace(/.*\//, '')
  log.info(`Buy token: ${buyToken}`)

  const sellDecimals = await w3.decimals(sellToken)
  log.info(`${sellToken} decimals: ${sellDecimals}`)

  const buyDecimals = await w3.decimals(buyToken)
  log.info(`${buyToken} decimals: ${buyDecimals}`)

	const fromAddress = await w3.getAddress(args.from || config.get('web3.defaultFrom'))
	log.info(`tx from: ${fromAddress}`)

	args.path = await w3.getPath(sellToken, buyToken, args.path)

	var balance
	var sellAmt
	var buyAmt
	if (amount.match(/max/i)) {
		balance = BN(
			await w3.access(
				sellToken,
				'balanceOf',
				fromAddress,
				null, // abi - not necessary
				args.from,
			)
		)

    log.info(`${sellToken} balance: ${balance.div(10 ** sellDecimals).toFixed()}`)

    sellAmt = new BN(ut.evalExpr('max', balance.toFixed(), amount, true)).decimalPlaces(0)

		buyAmt = new BN(
			(await w3.access(
				'UNISWAP_ROUTER2',
				'getAmountsOut',
				[	
					sellAmt.toFixed(),
					Array.from(JSON.parse(args.path)),
				],
				null,  //abi name
				args.from,
			)
		).slice(-1)[0]
		)

    log.info(`Uniswap final amount: ${sellAmt.toString()}`)
  } else {
		const tokenAmt = BN(amount).times(10 ** (buy ? Number(buyDecimals) : Number(sellDecimals))).decimalPlaces(0)
    
		if (buy) {
			sellAmt = BN(
				(
					await w3.access(
						'UNISWAP_ROUTER2',
						'getAmountsIn',
						[	
							tokenAmt.toFixed(),
							Array.from(JSON.parse(args.path)),
						],
						null,  //abi name
						args.from,
					)
				)[0])

			buyAmt = tokenAmt
		} else {
			sellAmt = tokenAmt

			buyAmt = BN(
				(
					await w3.access(
						'UNISWAP_ROUTER2',
						'getAmountsOut',
						[	
							sellAmt.toFixed(),
							Array.from(JSON.parse(args.path)),
						],
						null,  //abi name
						args.from,
					)
				).slice(-1)[0]
			)
		}
  }
	
  const dueTimestampSec = BN((new Date(chrono.parseDate(args.dueTime))).getTime()).div(1000).decimalPlaces(0).toFixed()

	var uniswapFunction = `swap\
		${buy ? '' : 'Exact'}\
    ${sellToken === 'ETH' ? 'ETH' : 'Tokens'}\
		For\
		${buy ? 'Exact' : ''}\
		${buyToken === 'ETH' ? 'ETH' : 'Tokens'}\
		${buy ? '' : 'SupportingFeeOnTransferTokens'}`.replace(/\s*/g, '')

	const ethValue = sellToken === 'ETH' ? sellAmt.toFixed() : null
	const minBuyAmount = buyAmt.times((100. - args.minPercent)/100.).decimalPlaces(0)
	const maxSellAmount = sellAmt.times((100. + args.minPercent)/100.).decimalPlaces(0)

	log.debug(JSON.stringify({
		ethValue,
		buyToken,
		buyAmt,
		minBuyAmount,
	}))

	log.debug(JSON.stringify({
		sellToken,
		sellAmt,
		maxSellAmount,
		dueTimestampSec,
	}))

	var uniswapArgs = 
		[
			sellAmt.toFixed(),
			buy ? maxSellAmount.toFixed() : minBuyAmount.toFixed(),
			Array.from(JSON.parse(args.path)),
			args.to || args.from,
			dueTimestampSec
		]

	if (!buy && sellToken === 'ETH') {
		// remove first element of args
		uniswapArgs.shift()
	}

  const a = [
		'UNISWAP_ROUTER2',
		uniswapFunction,
		uniswapArgs,
		null,  //abi name
		args.from,
		ethValue,
		args.gaslimit,
		args.gasprice
	]

	log.debug(`w3.access(${JSON.stringify(a.slice(0, 2))}...`)
	log.debug(`...${JSON.stringify(a.slice(2))})`)

  const priceToken = 
		buy 
		? 
      sellAmt.div(BN(10).pow(BN(sellDecimals))).div(buyAmt.div(BN(10).pow(BN(buyDecimals))))
    :
      buyAmt.div(BN(10).pow(BN(buyDecimals)))
      .div(sellAmt.div(BN(10).pow(BN(sellDecimals))))

	const priceDisp = priceToken.toFixed(6)
  const tokensDisp = buy ? buyToken+'/'+sellToken : sellToken + '/' + buyToken
  const buyDisp = buyAmt.div(BN(10).pow(BN(buyDecimals))).toFixed(6)
	var render = []
	if (/max/.test(amount)) {
		const sellDisp = sellAmt.div(BN(10).pow(BN(sellDecimals))).toFixed(6)

		render.push({
			action: 'sell',
			amount: sellDisp,
			token: sellToken
		})
	}

		render.push({
			action: 'price',
			amount: priceDisp,
			token: tokensDisp,
		})

		render.push({
			action: 'receive',
			amount: buyDisp,
			token: buyToken,
		})

	var display = columnify(render,
    {config: {
      amount: {align: 'right'},
		}})

  console.log(display)
	const accType = `web3.account.${await w3.getAddressName(args.from)}.type`
	console.log(accType)
	if (config.has(accType)) {
		if (config.get(accType) !== 'privatekey') {
			await pressAnyKey('Press any key to continue!')
		}
	} else {
		throw new Error('From address must be stored in ./config/secrets/default.yaml -> web3: -> account:')
	}

	const allowance = BN(await w3.access(sellToken, 'allowance', [args.from, 'UNISWAP_ROUTER2']))
	if (allowance.lt(sellAmt)) {
		await w3.access(
			sellToken,
			'approve',
			['UNISWAP_ROUTER2', BN(2).pow(256).minus(1).toFixed()],
			null,
			args.from,
			null,
			null,
			args.gasprice)
	}
	
	if (args.exchangeCommand !== 'trickle' ||
		( buy && priceToken.lt(args.batchMinRate)) ||
		(!buy && priceToken.gt(args.batchMinRate))) {

		const receipt = await w3.access(...a, null, args.exchangeCommand === 'trickle')
		
    if (!receipt.status) {
      log.error(`Transaction reverted`)
      log.debug(`Receipt: ${JSON.stringify(receipt)}`)
			return {id: 'skipped-order'}
    }
    return {id: 'no-order-id'}
	} else {
		log.warn(`Order skipped because Uniswap rate ${priceDisp} ${buy ? 'greater' : 'less'} than allowed rate ${args.batchMinRate}.`)
    return {id: 'skipped-order'}
	}
}

async function addOrderKyber (args, amount, buy) {

  if (args.type === 'limit') {
    log.error(`Limit orders not supported (yet).`)
    process.exit(1)
  }

  const sellToken = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
  log.info(`Sell token: ${sellToken}`)

  const buyToken = buy ? args.pair.replace(/\/.*/, '') : args.pair.replace(/.*\//, '')
  log.info(`Buy token: ${buyToken}`)

  const sellDecimals = await w3.decimals(sellToken)
  log.info(`${sellToken} decimals: ${sellDecimals}`)

  const buyDecimals = await w3.decimals(buyToken)
  log.info(`${buyToken} decimals: ${buyDecimals}`)

  var buyTokenCap
  try {
    buyTokenCap = new BN(await w3.access(
      'KyberNetworkProxy',
      'getUserCapInTokenWei',
      [
        config.get('web3.defaultFrom'),
        buyToken
      ]
    ))
  } catch (e) {
    buyTokenCap = new BN(w3.MAX_DEST_AMOUNT)
  }
  log.info(`Kyber ${buyToken} cap: ${buyTokenCap.div(10 ** buyDecimals).toString()}`)


  if (amount.match(/max/i)) {
    if (sellToken === 'ETH') {
      var balance = new BN(await w3.web3.eth.getBalance(await w3.getAddress(config.get('web3.defaultFrom'))))
    } else {
      balance = new BN(await w3.access(
        sellToken,
        'balanceOf',
        config.get('web3.defaultFrom'),
        'ERC20'
      ))
    }
    log.info(`Balance: ${balance.div(10 ** sellDecimals).toString()}`)

    let {expectedRate: kyberRate} = await w3.access(
      'KyberNetworkProxy',
      'getExpectedRate',
      [
        sellToken,
        buyToken,
        balance.toString(),
      ]
    )

    kyberRate = new BN(kyberRate)
    log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

    const maxSellAmt = ut.minBN(
      balance,
      buyTokenCap
      .times(10 ** sellDecimals) // decimals of sellToken
      .times(10 ** 18) // decimals of kyberRate
      .div(10 ** buyDecimals)  // decimals of buyToken
      .div(kyberRate),
    )

    log.info(`Kyber maxSellAmt: ${maxSellAmt.div(10 ** sellDecimals).toString()}`)

    var amt = new BN(ut.evalExpr('max', maxSellAmt.toString(), amount, true))
    log.info(`Kyber final amount: ${amt.toString()}`)
  } else {
    amount = new BN(amount)

    let {expectedRate: kyberRate} = await w3.access(
      'KyberNetworkProxy',
      'getExpectedRate',
      [
        sellToken,
        buyToken,
        '1000000000000000000',
      ])

    kyberRate = new BN(kyberRate)
    // log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

    if (kyberRate.toString() === '0') {
      log.error(`There is no liquidiy on Kyber.`)
      process.exit(1)
    }

    var sellTokenAmt = buy ? amount
      .times(10 ** buyDecimals)
      .times(10 ** 18)
      .div(kyberRate)
      .decimalPlaces(0)
      : amount
      .times(10 ** sellDecimals)
      .decimalPlaces(0)

    log.info(`Kyber sell token amount: ${sellTokenAmt.toString()}`)

    if (buy) { // iterate another to find a close enough sellTokenAmt
      let {'expectedRate': kyberRate} = await w3.access(
        'KyberNetworkProxy',
        'getExpectedRate',
        [
          sellToken,
          buyToken,
          sellTokenAmt.toString(),
        ]
      )

      kyberRate = new BN(kyberRate)
      log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

      sellTokenAmt = amount
        .times(10 ** buyDecimals)
        .times(10 ** 18)
        .div(kyberRate)
        .decimalPlaces(0)

      log.info(`Kyber amount: ${sellTokenAmt.toString()}`)
    }

    if (buyTokenCap.lt(sellTokenAmt.times(kyberRate))) {
      log.error(`Sell amount (${sellTokenAmt.times(kyberRate).toString()}) exceeds user cap (${buyTokenCap})`)
      throw new Error('Sell amount exceeds user cap')
    }
    amt = sellTokenAmt
  }

  let {expectedRate: kyberRate} = await w3.access(
    'KyberNetworkProxy',
    'getExpectedRate',
    [
      sellToken,
      buyToken,
      amt.toString(),
    ])

  kyberRate = new BN(kyberRate)
  log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)
  if (kyberRate.div(10 ** 18).gt(new BN(args.batchMinRate))) {
    const receipt = await w3.kyberTrade(
      config.get('web3.defaultFrom'),
      sellToken,
      amt.toString(),
      buyToken,
      config.get('web3.defaultFrom'),
      w3.MAX_DEST_AMOUNT,
      '0',
      '0x0000000000000000000000000000000000000000'
    )

    if (!receipt.status) {
      log.error(`Transaction reverted`)
      log.debug(`Receipt: ${JSON.stringify(receipt)}`)
      process.exit(1)
    }
    return {id: 'no-order-id'}
  } else {
    log.warn(`Order skipped because kyber rate ${kyberRate.div(10 ** 18).toString()} less than current min rate ${args.batchMinRate}.`)
    return {id: 'skipped-order'}
  }
}

async function addOrderCentralized (exchange, args, amount, buy, price) {
	const quoteToken = args.pair.replace(/.*\//, '')
	const baseToken = args.pair.replace(/\/.*/, '')
	const currPrice = await getPriceInOtherCurrency (args.exchange, baseToken, quoteToken)
	log.debug(`currPrice: ${currPrice}`)
	if (args.batchMinRate) {
		if ((buy && currPrice > args.batchMinRate) || (!buy && currPrice < args.batchMinRate)) {
			return {id: 'skipped-order'}
		}
	}
  if (amount.match(/max/i)) {
    const token = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
    const dust = config.get('dust-limit')
    const tokenAmount = (await listBalances(exchange, {token, dust}, {type: 'free'}))[token]
		log.debug(`tokenAmount: ${tokenAmount}`)
    if (args.type === 'limit') {
      var finalAmount = buy ? tokenAmount / args.price : tokenAmount
    } else {
      finalAmount = buy ? await getSpendAmountFromOrderbook(exchange, tokenAmount) : tokenAmount
    }
		log.debug(`finalAmount: ${finalAmount}`)
    amount = ut.evalExpr('max', finalAmount, amount)
  } else await exchange.loadMarkets()

  const market = exchange.markets[args.pair]

  log.debug('amount: ' + amount)
  if (args.type === 'market' && !exchange.has['createMarketOrder']) {
    const type = 'limit'
		
    const maxPrice = market['max'] && market['max']['price'] ?
      market['max']['price'] :
      1000000

		log.debug(`market maxPrice ${maxPrice}`)

    const minPrice = market['min'] && market['min']['price'] ?
      market['min']['price'] :
      0

		log.debug(`market minPrice ${minPrice}`)

    price = buy ? maxPrice : minPrice
    const {price: finalPrice, amount: finalAmount} = await fitPriceAndAmountToMarket(exchange, price, amount)
    return await exchange.createOrder(args.pair, type, args.side, finalAmount, finalPrice, args.params)
  } else {
    const {price: finalPrice, amount: finalAmount} = await fitPriceAndAmountToMarket(exchange, price, amount)
		log.debug(`finalPrice ${finalPrice} finalAmount ${finalAmount}`)
    return await exchange.createOrder(args.pair, args.type, args.side, finalAmount, finalPrice, args.params)
  }
}

async function fitPriceAndAmountToMarket (exchange, price, amount) {
  const market = exchange.markets[args.pair]
  
	const minAmount = market['min'] && market['min']['amount'] ? market['min']['amount'] : 0
  const maxAmount = market['max'] && market['max']['amount'] ? market['max']['amount'] : 1000000
	log.debug(`market minAmount: ${minAmount}`)	
	log.debug(`market maxAmount: ${maxAmount}`)	

	log.debug(`amount before check min max: ${amount}`)
  if (amount < minAmount) amount = minAmount
  if (amount > maxAmount) amount = maxAmount
	log.debug(`amount after  check min max: ${amount}`)

	log.debug(`amount before truncate: ${amount}`)
	log.debug(`amount precision: ${market.precision.amount}`)

	log.debug(`\
	sigdig ${SIGNIFICANT_DIGITS}\
	decpl: ${DECIMAL_PLACES}\
	final: ${exchange.id.match(/bitfinex|okex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES}\
	exchangeid: ${exchange.id}`)

	log.debug(`precision reported by market:${market.precision.amount}`)
  if (market.precision.amount !== 0) {	
		amount = decimalToPrecision(
			amount,
			TRUNCATE,
			//some exchanges report precision 
			market.precision.amount < 1 ? market.precision.amount.toString().split('.')[1].length || 0 : market.precision.amount,
			exchange.id.match(/bitfinex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES
		)
	}
	log.debug(`amount after truncate: ${amount}`)
	
	log.debug(`price before adust: ${price}`)
  if (price) {
    const maxPrice = market['max'] ?
      market['max']['price'] :
      1000000

    const minPrice = market['min'] ?
      market['min']['price'] :
      0

    price = price < minPrice ? minPrice : price
    price = price > maxPrice ? maxPrice : price
    if (
      market['max'] &&
      market['max']['cost'] &&
      amount * price > market['max']['cost']
    ) {
      price = market['max']['cost'] / amount
    }

    if (
      market['min'] &&
      market['min']['cost'] &&
      amount * price < market['min']['cost']
    ) {
      price = market['max']['cost'] / amount
    }
		log.debug(`price before adust: ${price}`)

		log.debug(`price before truncate: ${price}`)
		log.debug(`price precision: ${market.precision.price}`)

		log.debug(`\\
		sigdig ${SIGNIFICANT_DIGITS} decpl: ${DECIMAL_PLACES}\\
		final: ${exchange.id.match(/bitfinex|okex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES}\\
		exchangeid: ${exchange.id}`)

		price = decimalToPrecision(
      price,
      TRUNCATE,
			market.precision.price < 1 ? market.precision.price.toString().split('.')[1].length || 0 : market.precision.price,
      exchange.id.match(/bitfinex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES
    )

		log.debug(`price after truncate: ${price}`)

  }
  return {price, amount}
}

async function getSpendAmountFromOrderbook (exchange, tokenAmount) {
  const orderbook = await getOrderbook(exchange, args)
  var amountToSpend = tokenAmount
  var orderNum = 0
  var finalAmount = 0
  while (amountToSpend > 0 && orderNum < orderbook.asks.length) {
    const sellPrice = orderbook.asks[orderNum][0]
    const sellAmount = orderbook.asks[orderNum][1]
    if (amountToSpend > sellPrice * sellAmount) {
      finalAmount += sellAmount
      amountToSpend -= sellPrice * sellAmount
    } else {
      finalAmount += amountToSpend / sellPrice
      amountToSpend = 0
    }
    orderNum++
  }
  return finalAmount
}

async function lockedAmount (exchange, token) {
  const orders = await listOrders(exchange, {pair: undefined, since: undefined, limit: undefined})
  const pairBuy = new RegExp('.*/' + token)
  const pairSell = new RegExp(token + '/.*')
  return orders.filter(
    order => order.side === 'buy' && order.symbol.match(pairBuy) ||
    order.side === 'sell' && order.symbol.match(pairSell)
  )
    .map(order => order.side === 'buy' ? order.remaining * order.price : order.remaining)
    .reduce((total, remaining) => total + remaining, 0)
}

async function dispListOrders (exchange, args) {
  const orders = await listOrders(exchange, args)
  orders.map(order => console.log(order.id + ' ' + order.type + ' ' + order.side + ' ' + order.amount + ' ' + order.symbol + ' ' + order.price))
}

async function listOrders (exchange, args) {
  if (exchange.id === 'binance') {
    exchange.options['warnOnFetchOpenOrdersWithoutSymbol'] = false
    console.log('Rate limit: Do not start this in 271 secs to avoid ban.')
  }
  const fetchOrders = args.closed ? exchange.fetchClosedOrders.bind(exchange) : exchange.fetchOpenOrders.bind(exchange)
  args.closed && exchange.loadMarkets()
  if (!args.closed && exchange.has['fetchOpenOrders'] ||
    args.closed && exchange.has['fetchClosedOrders']) {
    return await fetchOrders(args.pair, args.since, args.limit)
  } else {
    throw new Error('Exchange does not support fetching open offers.')
  }
}

async function dispDeposit (exchange, args) {
  console.log(await deposit(exchange, args))
}

async function deposit (exchange, args) {
  const deposit = await exchange.fetchDepositAddress(args.token)
  return deposit.address
}

async function withdraw (exchange, args) {
  var amt = args.amount
  if (amt.match(/max/i)) {

    // security check

    args.dust = config.get('dust-limit')
    const balances = await listBalances(exchange, args)
    const balanceValue = balances[args.token]
    const lockedValue = await lockedAmount(exchange, args.token)
    amt = ut.evalExpr('max', balanceValue - lockedValue, amt)

    amt = decimalToPrecision(
      amt,
      TRUNCATE,
      args.digits,
      DECIMAL_PLACES
    )
  }

  log.debug('amount:', amt)
  const confStart = 'withdraw.' + args.exchange
  var confToken = confStart + '.' + args.token
  if (!config.has(confToken)) {
    confToken = confStart + '.default'
    if (!config.has(confToken)) {
      throw new Error('Withdrawal for token ' + args.token + ' not defined in config.')
    }
  }
  const confDestPart = confToken + '.' + args.destination
  const confDestination = confDestPart + '.destination'
  const confTag = confDestPart + '.tag'
  const confParams = confDestPart + '.params'
  var tag
  if (config.has(confTag)) tag = config.get(confTag)
  const address = config.get(confDestination)
  const params = config.get(confParams)
  await exchange.withdraw(args.token, amt, address, tag, params)
}

async function dispListBalances (exchange, args, params) {
  const balances = await listBalances(exchange, args, params)
  Object.keys(balances).map(currency => console.log(currency + ' ' + balances[currency]))
}

async function listBalances (exchange, args, params = {}) {
	var filtered
  var balances = await exchange.fetchBalance(params)
	const balanceType = (params && params.type) || 'total'
  var balance = balances[balanceType]
	log.debug(`balance from ccxt: ${JSON.stringify(balance)}`)
	log.debug(`typeof balance: ${typeof balance}`)
	if (typeof balance === 'undefined' || JSON.stringify(balance) === '{}') { 
		log.warn(`balance is not useable`)

		//log.debug(`balances: ${JSON.stringify(balances)}`)
		balances = balances.info.balances &&
			balances.info.balances.reduce(
				(entry, asset) => {
					entry = {
						...entry,
						[asset.asset]:{
							free: Number(asset.free),
							locked: Number(asset.locked),
							total: Number(asset.locked) + Number(asset.free)
						},
					
						total: {
							...entry.total,
							[asset.asset]: Number(asset.locked) + Number(asset.free)
						},

						free: {
							...entry.free,
							[asset.asset]: Number(asset.free)
						},
					
						locked: {
							...entry.locked,
							[asset.asset]: Number(asset.locked)
						}
					}

					return entry
				},
			{})
 
		//log.debug(`balances: ${JSON.stringify(balances)}`)
		balance = balances[balanceType]
	}

	log.debug(JSON.stringify(balance))
	log.debug(`args.token: ${args.token}`)
	if (typeof balance !== 'undefined') { 
    filtered = Object
    .keys(balance)
    .filter(currency => balance[currency] >= args.dust && (!args.token || args.token === currency))
    .reduce((bal, currency) => { bal[currency] = balance[currency]; return bal }, {})
	} else {
		if (params.type === 'free') {
			balance = balances['total']

			filtered = Object
				.keys(balance)
				.filter(currency => balance[currency] >= args.dust && (!args.token || args.token === currency))

			filtered = await filtered
				.reduce(async (bal, currency) => { bal[currency] = balance[currency] - await lockedAmount(exchange, currency); return bal }, {})
		}
	}
  return filtered
}

function argParse () {

  var parser = new ArgumentParser({
    version: '0.0.1',
    addHelp: true,
    description: 'Exchange money and interact with Ethereum blockchain.',
  })

  parser.addArgument(
    ['--pm2'],
    {
      action: 'storeTrue',
      help: 'Current process is a pm2 started one.',
    }
  )

  var subparsers = parser.addSubparsers({
    title: 'subcommands',
    dest: 'subCommand',
  })

  var exchange = subparsers.addParser('exchange', 
		{
			addHelp: true,
			description: 'Exchange tokens via centralized or decentralized exchanges.'
		}
)

  var exchangeparsers = exchange.addSubparsers({
    title: 'subcommands',
    dest: 'exchangeCommand',
  })

  var listOrders = exchangeparsers.addParser('listorders', 
		{
			addHelp: true,
			description: 'List all open orders on exchange.'
		}
)

  listOrders.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  listOrders.addArgument(
    ['--token', '-t'],
    {
      action: 'store',
      help: 'Token to list',
    }
  )

  listOrders.addArgument(
    ['--closed', '-c'],
    {
      action: 'storeTrue',
      help: 'List closed offers.',
    }
  )

  listOrders.addArgument(
    ['--pair', '-p'],
    {
      action: 'store',
      help: 'The pair to look orders for.',
    }
  )

  var add = exchangeparsers.addParser('add', 
		{
			addHelp: true,
			description: 'Add new order to exchange.'
		}
)

  add.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  add.addArgument(
    ['side'],
    {
      action: 'store',
      choices: ['buy', 'sell'],
      help: 'The order side',
    }
  )

  add.addArgument(
    ['type'],
    {
      action: 'store',
      choices: ['limit', 'market'],
      help: 'The order side',
    }
  )

  add.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'The order amount to buy or sell. Should be a number or an expression of "max" to do the max available.',
    }
  )

  add.addArgument(
    ['pair'],
    {
      action: 'store',
      help: 'The standard names of token pair eg: "ETH/USD".',
    }
  )

  add.addArgument(
    ['price'],
    {
      action: 'store',
      help: 'Price of the order. Ignored if market order.',
    }
  )

	add.addArgument(
    ['--due-time', '-t'],
    {
      action: 'store',
      defaultValue: '10 minutes from now',
      dest: 'dueTime',
      help: 'Uniswap only. Minimum amount requeseted. Uses free text to define end time using chrono lib.',
    }
  )

	add.addArgument(
    ['--min-percent', '-m'],
    {
      action: 'store',
      dest: 'minPercent',
      type: Number,
      defaultValue: '1',
      help: 'Uniswap only. The minimum output amount can be this percent less then calculated output amount.',
    }
  )

	add.addArgument(
    ['--max-slippage', '-s'],
    {
      action: 'store',
			dest: 'maxSlippage',
      help: 'Uniswap only. Maximum allowed slippage.',
    }
  )

	add.addArgument(
		['--path', '-x'],
    {
      action: 'store',
      help: 'Uniswap only. Path to exchange sell- to buyToken. ',
    }
  )

  add.addArgument(
    ['--from', "-f"],
    {
      action: 'store',
			defaultValue: config.get('web3.defaultFrom'),
      help: 'Decentralized swaps only. From Address defaults to web3.defaultFrom',
    }
  )

  add.addArgument(
    ['--gaslimit', "-g"],
    {
      action: 'store',
      help: 'Decentralized swaps only. Gaslimit of transaction',
    }
  )

  add.addArgument(
    ['--to', "-o"],
    {
      action: 'store',
      help: 'Uniswap only. Recipient of output tokens',
    }
  )

  add.addArgument(
    ['--gasprice', "-p"],
    {
      action: 'store',
      help: 'Decentralized swaps only. Gas price of transaction',
    }
  )

  add.addArgument(
    ['--params'],
    {
      action: 'store',
      help: 'Extra parameters for exchange in json string format.',
    }
  )

  var remove = exchangeparsers.addParser('rm', 
		{
			addHelp: true,
			description: 'Remove order from exchange.'
		}
)

  remove.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  remove.addArgument(
    ['order'],
    {
      action: 'store',
      type: String,
      help: 'The order id to cancel',
    }
  )

  var removeAll = exchangeparsers.addParser('rmall', 
		{
			addHelp: true,
			description: 'Remove all open orders from exchange.'
		}
)

  removeAll.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  var listBalances = exchangeparsers.addParser('listbalances', 
		{
			addHelp: true,
			description: 'List all non-dust balances on exchange.'
		}
)

  listBalances.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  listBalances.addArgument(
    ['--token', '-t'],
    {
      action: 'store',
      help: 'Token to list',
    }
  )

  if (config.has('dust-limit')) {
    dust = config.get('dust-limit')
  }

  listBalances.addArgument(
    ['--dust-limit', '-d'],
    {
      action: 'store',
      type: Number,
      defaultValue: dust,
      dest: 'dust',
      help: 'Amounts less than dust-limit will not be listed',
    }
  )

  var withdraw = exchangeparsers.addParser('withdraw', 
		{
			addHelp: true,
			description: 'Withdraw token from exchange.'
		}
)

  withdraw.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  withdraw.addArgument(
    ['--digits', '-d'],
    {
      action: 'store',
      type: Number,
      defaultValue: 2,
      help: 'Digits used after comma for withdrawal.',
    }
  )

  withdraw.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token to withdraw.',
    }
  )

  withdraw.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Amount to withdraw. Can be "max".',
    }
  )

  withdraw.addArgument(
    ['destination'],
    {
      action: 'store',
      help: 'Destination to withdraw to.',
    }
  )

  var deposit = exchangeparsers.addParser('deposit', 
		{
			addHelp: true,
			description: 'Get deposit address of token for exchange.'
		}
)

  deposit.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  deposit.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token to deposit.',
    }
  )

  const market = exchangeparsers.addParser('markets', 
		{
			addHelp: true,
			description: 'Display all token pairs on exchange.'
		}
)

  market.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  var price = exchangeparsers.addParser('price', 
		{
			addHelp: true,
			description: 'Get price of token.'
		}
)

  price.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  price.addArgument(
    ['pair'],
    {
      action: 'store',
      help: 'Tokenpair to get price for.',
    }
  )

  price.addArgument(
    ['--amount', '-a'],
    {
      action: 'store',
      help: 'Get average price for buying "amount" from token based on orderbook.',
    }
  )

  price.addArgument(
    ['--sell', '-s'],
    {
      action: 'storeTrue',
      help: 'Get average price for selling amount from token.',
    }
  )

  price.addArgument(
    ['--usd', '-u'],
    {
      action: 'storeTrue',
      help: 'Get price in USD from coinbasepro',
    }
  )

  price.addArgument(
    ['--eur', '-e'],
    {
      action: 'storeTrue',
      help: 'Get price in USD from coinbasepro',
    }
  )

  var orderbook = exchangeparsers.addParser('orderbook', 
		{
			addHelp: true,
			description: 'Download orderbook from exchange.'
		}
)

  orderbook.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  orderbook.addArgument(
    ['pair'],
    {
      action: 'store',
      help: 'Tokenpair to get price for.',
    }
  )

  orderbook.addArgument(
    ['--currency', '-c'],
    {
      action: 'store',
      help: 'Show prices in currency instead of the quote currency.',
    }
  )

  orderbook.addArgument(
    ['--other-exchange', '-o'],
    {
      action: 'store',
      dest: 'otherExchange',
      defaultValue: 'coinbasepro',
      help: 'The other exchange to get currency price from.',
    }
  )

  orderbook.addArgument(
    ['--limit', '-l'],
    {
      action: 'store',
      help: 'Limit of the number of items in orderbook.',
    }
  )

  orderbook.addArgument(
    ['--price-precision', '-p'],
    {
      action: 'store',
      dest: 'pPrecision',
      type: Number,
      help: 'Precision of prices.',
    }
  )

  orderbook.addArgument(
    ['--amount-precision', '-a'],
    {
      action: 'store',
      dest: 'aPrecision',
      type: Number,
      help: 'Precision of amounts.',
    }
  )

  var trickle = exchangeparsers.addParser('trickle', 
		{
			addHelp: true,
			description: 'Buy or sell in small batches not to ruin market price.'
		}
)

  trickle.addArgument(
    ['--batch-size', '-s'],
    {
      action: 'store',
      dest: 'batchSize',
      type: Number,
      help: 'Buy/sell this much at one batch.',
    }
  )

  trickle.addArgument(
    ['--batch-size-variance', '-v'],
    {
      action: 'store',
      dest: 'batchSizeVariance',
      type: Number,
      defaultValue: 0,
      help: 'Maximum this much is added to batch size. Evenly distributed random number generated.',
    }
  )

  trickle.addArgument(
    ['--batch-min-rate', '-m'],
    {
      action: 'store',
      dest: 'batchMinRate',
      type: Number,
      help: 'Minimum/maximum rate at which the trade executes.',
    }
  )

  trickle.addArgument(
    ['--batch-retry-time', '-y'],
    {
      action: 'store',
      dest: 'batchRetrySec',
      type: Number,
      defaultValue: 60,
      help: 'Retry time after offer skipped because price was less than args.batchMinRate.',
    }
  )

  trickle.addArgument(
    ['--batch-time', '-t'],
    {
      action: 'store',
      dest: 'batchTime',
      type: Number,
      help: 'Sell a batch every batch-time seconds.',
    }
  )

  trickle.addArgument(
    ['--batch-time-variance', '-r'],
    {
      action: 'store',
      dest: 'batchTimeVariance',
      type: Number,
      defaultValue: 0,
      help: 'Maximum this much is added to batch time. Evenly distributed random number generated.',
    }
  )

  trickle.addArgument(
    ['--params'],
    {
      action: 'store',
      help: 'Extra parameters for exchange in json string format.',
    }
  )

	trickle.addArgument(
    ['--due-time', '-u'],
    {
      action: 'store',
      defaultValue: '10 minutes from now',
      dest: 'dueTime',
      help: 'Uniswap only. Minimum amount requeseted. Uses free text to define end time using chrono lib.',
    }
  )

	trickle.addArgument(
    ['--min-percent', '-p'],
    {
      action: 'store',
      dest: 'minPercent',
      type: Number,
      defaultValue: '1',
      help: 'Uniswap only. The minimum output amount can be this percent less then calculated output amount.',
    }
  )

	trickle.addArgument(
    ['--max-slippage', '-l'],
    {
      action: 'store',
			dest: 'maxSlippage',
      help: 'Uniswap only. Maximum allowed slippage.',
    }
  )

	trickle.addArgument(
		['--path', '-x'],
    {
      action: 'store',
      help: 'Uniswap only. Path to exchange sell- to buyToken. ',
    }
  )

  trickle.addArgument(
    ['--from', "-f"],
    {
      action: 'store',
			defaultValue: config.get('web3.defaultFrom'),
      help: 'Decentralized swaps only. From Address defaults to web3.defaultFrom',
    }
  )

  trickle.addArgument(
    ['--gaslimit', "-g"],
    {
      action: 'store',
      help: 'Decentralized swaps only. Gaslimit of transaction',
    }
  )

  trickle.addArgument(
    ['--to', "-o"],
    {
      action: 'store',
      help: 'Uniswap only. Recipient of output tokens',
    }
  )

  trickle.addArgument(
    ['--gasprice', "-c"],
    {
      action: 'store',
      help: 'Decentralized swaps only. Gas price of transaction',
    }
  )

  trickle.addArgument(
    ['exchange'],
    {
      action: 'store',
      choice: Object.keys(config.get('keys')),
      help: 'Name of exchange.',
    }
  )

  trickle.addArgument(
    ['side'],
    {
      action: 'store',
      choices: ['buy', 'sell'],
      help: 'The order side',
    }
  )

  trickle.addArgument(
    ['type'],
    {
      action: 'store',
      choices: ['limit', 'market'],
      help: 'The order side',
    }
  )

  trickle.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'The order amount to buy or sell. Should be a number or an expression of "max" to do the max available.',
    }
  )

  trickle.addArgument(
    ['pair'],
    {
      action: 'store',
      help: 'The standard names of token pair eg: "ETH/USD".',
    }
  )

  trickle.addArgument(
    ['price'],
    {
      action: 'store',
      help: 'Price of the order. Ignored if market order.',
    }
  )

  var eth = subparsers.addParser('eth', 
		{
			addHelp: true,
			description: 'Do stuff with the Ethereum blockchain.'
		}
)

	eth.addArgument( 
    ['--from', "-f"],
    {
      action: 'store',
      defaultValue: config.get('web3.defaultFrom'),
      help: 'From Address defaults to web3.defaultFrom',
    }
  )

  var ethparsers = eth.addSubparsers({
    title: 'subcommands',
    dest: 'ethCommand',
  })

  var tx = ethparsers.addParser('tx', 
		{
			addHelp: true,
			description: 'Create an ethereum transaction. Send or call method is used automatically based on abi.'
		}
)

  tx.addArgument(
    ['contract'],
    {
      action: 'store',
      help: 'Contract address',
    }
  )

  tx.addArgument(
    ['func'],
    {
      action: 'store',
      help: 'Function name to call or send',
    }
  )

  tx.addArgument(
    ['args'],
    {
      action: 'store',
      nargs: '*',
      help: 'Called function\'s arguments',
    }
  )

  tx.addArgument(
    ['--abi', "-a"],
    {
      action: 'store',
      help: 'Abi defaults to <contract>.abi',
    }
  )

  tx.addArgument(
    ['--from', "-f"],
    {
      action: 'store',
			defaultValue: config.get('web3.defaultFrom'),
      help: 'From Address defaults to web3.defaultFrom',
    }
  )

  tx.addArgument(
    ['--value', "-v"],
    {
      action: 'store',
      help: 'Eth value to send',
    }
  )

  tx.addArgument(
    ['--gaslimit', "-g"],
    {
      action: 'store',
      help: 'Gaslimit of transaction',
    }
  )

  tx.addArgument(
    ['--gasprice', "-p"],
    {
      action: 'store',
      help: 'Gas price of transaction',
    }
  )

  tx.addArgument(
    ['--ls', "-l"],
    {
      action: 'store',
      help: 'List functions in abi matching pattern.',
    }
  )

  const abi = ethparsers.addParser('abi', 
		{
			addHelp: true,
			description: 'Displays abi of smart contract.'
		}
)

  abi.addArgument(
    ['contract'],
    {
      action: 'store',
      help: 'Contract address',
    }
  )

  abi.addArgument(
    ['--ls', '-l'],
    {
      action: 'store',
			defaultValue: '.*',
      help: 'List functions matching regex pattern.',
    }
  )

  const send = ethparsers.addParser('send', 
		{
			addHelp: true,
			description: 'Sends a prepared transaction (json formatted) to the blockchain.'
		}
)

  send.addArgument(
    ['txjson'],
    {
      action: 'store',
      help: 'Json file of the transaction',
    }
  )

  send.addArgument(
    ['signature'],
    {
      action: 'store',
      help: 'Signature created by external signer',
    }
  )

  const address = ethparsers.addParser('address', 
		{
			addHelp: true,
			description: 'Get contract address from contract name, or vica versa.'
		}
)

  address.addArgument(
    ['contr'],
    {
      action: 'store',
      help: 'Contract address or contract name',
    }
  )

  const source = ethparsers.addParser('source',
		{
			addHelp: true,
			description: 'Download and display source code of contract.'
		}
	)

  source.addArgument(
    ['contractName'],
    {
      action: 'store',
      help: 'Contract name',
    }
  )

	const im = ethparsers.addParser('import',
		{
			description:'Map contract address to a human readable name and download and store  contract abi.',
			addHelp: true,
		})

  im.addArgument(
    ['contractName'],
    {
      action: 'store',
      help: 'Human readable shorthand name for contract. When contract name is used later on, it will be substituted by contract address automatically.',
    }
  )

  im.addArgument(
    ['contractAddress'],
    {
      action: 'store',
      help: 'Contract address',
    }
  )

  im.addArgument(
    ['--location', '-l'],
    {
      action: 'store',
      help: 'Insert contract into path in "./config/default.yaml".'
    }
  )

	//---------------------------
  var maker = ethparsers.addParser('maker', 
		{
			addHelp: true,
			description: 'Commands to operate MakerDao vaults.'
		}
)

  maker.addArgument(
    ['--vault', '-v'],
    {
      action: 'store',
      type: Number,
			defaultValue: 0,
			help: 'The number of vault to operate with',
    }
  )

	maker.addArgument( //FIXME: not implemented in methods.
    ['--from', "-f"],
    {
      action: 'store',
      defaultValue: config.get('web3.defaultFrom'),
      help: 'From Address defaults to web3.defaultFrom',
    }
  )

  maker.addArgument(
    ['--estimate', "-e"],
    {
      action: 'storeTrue',
      help: 'Returns expected gas cost in USD.',
    }
  )

  var makerparser = maker.addSubparsers({
    title: 'subcommands',
    dest: 'makerCommand',
  })

  var vaultInfo = makerparser.addParser('info', 
		{
			addHelp: true,
			description: 'Get vault info.'
		}
)

  vaultInfo.addArgument(
    ['type'],
    {
      action: 'store',
			help: 'Type of vault to get info from. Eg.: USDC-A',
    }
  )

  var open = makerparser.addParser('open', 
		{
			addHelp: true,
			description: 'Open new MakerDao vault.'
		}
)

  open.addArgument(
    ['type'],
    {
      action: 'store',
      help: 'Type of vault that will be created',
    }
  )

  var collateralDeposit = makerparser.addParser('deposit', 
		{
			addHelp: true,
			description: 'Deposit collateral to vault.'
		}
)

  collateralDeposit.addArgument(
    ['type'],
    {
      action: 'store',
      help: 'Type of vault that will be deposited to. Eg.: ETH-A',
    }
  )

  collateralDeposit.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Deposit amount of collateral.',
    }
  )

  collateralDeposit.addArgument(
    ['--draw', '-d'],
    {
      action: 'store',
			type: Number,
			defaultValue: 0,
      help: 'Draw create DAI to the urn in one step',
    }
  )

  var collateralWithdraw = makerparser.addParser('withdraw', 
		{
			addHelp: true,
			description: 'Withdraw collateral from vault.'
		}
)

  collateralWithdraw.addArgument(
    ['type'],
    {
      action: 'store',
      help: 'Type of vault that will be withdrawn from. Eg.: ETH-A',
    }
  )

  collateralWithdraw.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Withdraw amount of collateral.',
    }
  )

  var generate = makerparser.addParser('generate', 
		{
			addHelp: true,
			description: 'Generate DAI stablecoin.'
		}
)

  generate.addArgument(
    ['type'],
    {
      action: 'store',
      help: 'Type of vault that DAI will be generated from. Eg.: ETH-A',
    }
  )

  generate.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Amount of DAI to generate.',
    }
  )

  var payback = makerparser.addParser('payback', 
		{
			addHelp: true,
			description: 'Payback an amount of DAI to vault type.'
		}
)

  payback.addArgument(
    ['type'],
    {
      action: 'store',
      help: 'Type of vault that DAI will be paid back to. Eg.: ETH-A',
    }
  )

  payback.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Amount of DAI paid back.',
    }
  )
  // eslint-disable-next-line
  var estimate = makerparser.addParser('estimate', 
		{
			addHelp: true,
			description: 'Estimate gas cost of ??. Don\'t use this!'
		}
)

  var flop = makerparser.addParser('flop', 
		{
			addHelp: true,
			description: 'Make a count of new bids.'
		}
)

  flop.addArgument(
    ['--count', '-c'],
    {
      action: 'store',
      help: 'Number of new bids to make',
    }
  )

  var tick = makerparser.addParser('tick', 
		{
			addHelp: true,
			description: 'Bid a better price for an expired auction.'
		}
)

  tick.addArgument(
    ['id'],
    {
      action: 'store',
      help: 'Make an expired auction have better price.',
    }
  )

  var dent = makerparser.addParser('dent', 
		{
			addHelp: true,
			description: 'Bid for an auction of id.'
		}
)

  dent.addArgument(
    ['id'],
    {
      action: 'store',
      help: 'Identifier of auction to make bid for.',
    }
  )

  dent.addArgument(
    ['--amount', '-a'],
    {
      action: 'store',
      help: 'Amount to bid. Default amount is the minimal necessary.',
    }
  )

  var deal = makerparser.addParser('deal', 
		{
			addHelp: true,
			description: 'Finish an auction and receive MKR'
		}
)

  deal.addArgument(
    ['id'],
    {
      action: 'store',
      help: 'Idealifier of auction to finish.',
    }
  )

  var flog = makerparser.addParser('flog', 
		{
			addHelp: true,
			description: 'Get events of bad debt from contract from blocknumber to blocknumber.'
		}
)

  flog.addArgument(
    ['contract'],
    {
      action: 'store',
      help: 'Contract to get events from',
    }
  )

  flog.addArgument(
    ['--from-block', '-f'],
    {
      action: 'store',
      defaultValue: 'latest',
      help: 'Startblock to get events from',
    }
  )

  flog.addArgument(
    ['--to-block', '-t'],
    {
      action: 'store',
      defaultValue: 'latest',
      help: 'End block to get events from.',
    }
  )

  flog.addArgument(
    ['--amount', '-a'],
    {
      action: 'store',
      defaultValue: 50000,
      type: Number,
      help: 'Amount of max. dai to allow auction for.',
    }
  )

  var aave = ethparsers.addParser('aave', 
		{
			addHelp: true,
			description: 'Commands accessing https://aave.com lending protocol.'
		}
)

  aave.addArgument(
    ['--referral', '-r'],
    {
      action: 'store',
			defaultValue: '0',
			help: 'Referral code in AAVE system.',
    }
  )

  aave.addArgument(
    ['--from', "-f"],
    {
      action: 'store',
      defaultValue: config.get('web3.defaultFrom'),
      help: 'From Address defaults to web3.defaultFrom',
    }
  )

  aave.addArgument(
    ['--estimate', "-e"],
    {
      action: 'storeTrue',
      help: 'Returns expected gas cost in USD.',
    }
  )

  var aaveParser = aave.addSubparsers({
    title: 'subcommands',
    dest: 'aaveCommand',
  })

  var aaveDeposit = aaveParser.addParser('deposit', 
		{
			addHelp: true,
			description: 'Deposit an amount of token to aave.'
		}
)

  aaveDeposit.addArgument(
    ['amount'],
    {
      action: 'store',
			help: 'Amount you want to deposit',
    }
  )

  aaveDeposit.addArgument(
    ['token'],
    {
      action: 'store',
			help: 'Token you want to deposit',
    }
  )

  var aaveWithdraw = aaveParser.addParser('withdraw', 
		{
			addHelp: true,
			description: 'Withdraw an amount of token from aave.'
		}
)

  aaveWithdraw.addArgument(
    ['amount'],
    {
      action: 'store',
			help: 'Amount you want to withdraw',
    }
  )

  aaveWithdraw.addArgument(
    ['token'],
    {
      action: 'store',
			help: 'Token you want to withdraw',
    }
  )

  var aaveColl = aaveParser.addParser('collateral', 
		{
			addHelp: true,
			description: 'Enable(/disable) token as collateral in aave.'
		}
)

  aaveColl.addArgument(
    ['token'],
    {
      action: 'store',
			help: 'Token you want to use as collateral',
    }
  )

  aaveColl.addArgument(
    ['--disable'],
    {
      action: 'storeTrue',
			help: 'Disable to use token as collateral',
    }
  )

  var aaveBorrow = aaveParser.addParser('borrow', 
		{
			addHelp: true,
			description: 'Borrow an amount of token against a collateral in aave.'
		}
)

  aaveBorrow.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Deposit amount of collateral.',
    }
  )

  aaveBorrow.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token that w',
    }
  )

  aaveBorrow.addArgument(
    ['--fixed', '-d'],
    {
      action: 'storeTrue',
			help: 'Use fixed interests. Default: variable interests.',
    }
  )

  var aavePayback = aaveParser.addParser('payback', 
		{
			addHelp: true,
			description: 'Payback an amount of token for ourselfes or others.'
		}
)

  aavePayback.addArgument(
    ['amount'],
    {
      action: 'store',
      help: 'Amount to payback',
    }
  )

  aavePayback.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token to payback.',
    }
  )

  aavePayback.addArgument(
    ['--for', '-f'],
    {
      action: 'store',
			help: 'Payback for someone else.',
    }
  )

  var aaveSwaprate = aaveParser.addParser('swaprate', 
		{
			addHelp: true,
			description: 'Toggle between fixed and variable rate for token.'
		}
)

  aaveSwaprate.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token to swap the rate between fixed and variable.',
    }
  )

  var aaveRebalance = aaveParser.addParser('rebalance', 
		{
			addHelp: true,
			description: 'Rebalancei (actualize) fixed interest rate for token for ourselves or others.'
		}
)

  aaveRebalance.addArgument(
    ['token'],
    {
      action: 'store',
      help: 'Token to rebalance interest rate for.',
    }
  )

  aaveRebalance.addArgument(
    ['--for'],
    {
      action: 'store',
			help: 'Address to rebalance for. Default: '+ config.get('web3.defaultFrom'),
    }
  )

  var aaveLiquidate = aaveParser.addParser('liquidate', 
		{
			addHelp: true,
			description: 'Liquidate undercollaterized position for collateral token and loan token owned by address.'
		}
)

  aaveLiquidate.addArgument(
    ['collateraltoken'],
    {
      action: 'store',
      help: 'Token that is the collateral.',
    }
  )

  aaveLiquidate.addArgument(
    ['loantoken'],
    {
      action: 'store',
      help: 'Token that is used for the loan',
    }
  )

  aaveLiquidate.addArgument(
    ['user'],
    {
      action: 'store',
			help: 'Address of user who has the loan.',
    }
  )

  aaveLiquidate.addArgument(
    ['amount'],
    {
      action: 'store',
			help: 'Amount of collateral to buy(???)', //FIXME: have no idea what that is
    }
  )

  var aaveInfo = aaveParser.addParser('info', 
		{
			addHelp: true,
			description: 'Get info on reserves.'
		}
)

  var aaveI = aaveInfo.addSubparsers({
    title: 'subcommands',
    dest: 'aaveInfoCommand',
  })

  var aaveReserveconf = aaveI.addParser('reserve', 
		{
			addHelp: true,
			description: 'Get info on token reserve.'
		}
)

  aaveReserveconf.addArgument(
    ['token'],
    {
      action: 'store',
			help: 'Get info for token reserve',
    }
  )

  var aaveUserAccount = aaveI.addParser('account', 
		{
			addHelp: true,
			description: 'Get account info for account address.'
		}
)

	aaveUserAccount.addArgument( 
    ['--from', "-f"],
    {
      action: 'store',
      defaultValue: config.get('web3.defaultFrom'),
			help: 'Account address. (Defaults to ./config/default.yaml -> web3.defaultFrom)'
    })

  var aaveUserReserve = aaveI.addParser('user', 
		{
			addHelp: true,
			description: 'Get info on token reserves.'
		}
)

  aaveUserReserve.addArgument(
    ['token'],
    {
      action: 'store',
			help: 'Get info for token reserve',
    }
  )
  // eslint-disable-next-line
  var aaveEstimate = aaveParser.addParser('estimate', {addHelp: true})

  var curve = ethparsers.addParser('curve', 
		{
			addHelp: true,
			description: 'Commands accessing https://curve.fi protocol.'
		}
)

  var curveparsers = curve.addSubparsers({
    title: 'subcommands',
    dest: 'curveCommand',
  })

  var info = curveparsers.addParser('info', 
		{
			addHelp: true,
			description: 'Get info on all curve pools, own deposits, daily CRV amounts, future boost, depositable amounts for maximum boost.'
		}
)

	info.addArgument( 
    ['--from', "-f"],
    {
      action: 'store',
      defaultValue: config.get('web3.defaultFrom'),
      help: 'From Address defaults to web3.defaultFrom',
    }
  )

  var ledger = subparsers.addParser('ledger', 
		{
			addHelp: true,
			description: 'Do stuff with Ledger cold wallet https://www.ledger.com/ .'
		}
)

  var ledgerparsers = ledger.addSubparsers({
    title: 'subcommands',
    dest: 'ledgerCommand',
  })

  var addresses = ledgerparsers.addParser('addresses', 
		{
			addHelp: true,
			description: 'List first ten addresses.'
		}
	)

	addresses.addArgument( 
    ['--wallet', "-w"],
    {
      action: 'store',
      choices: ['Ethereum'],
      defaultValue: 'Ethereum',
      help: 'Wallet to connect to. Currently only Ethereum is supported.',
    }
  )

	addresses.addArgument( 
    ['--live', "-l"],
    {
      action: 'store',
      help: 'Connect to ledger live vallets only.',
    }
  )

	addresses.addArgument( 
    ['--start-position', "-s"],
    {
      action: 'store',
			dest: 'startPosition',
      defaultValue: 0,
      help: 'List accounts starting from this position. Starting at 0.',
    }
  )

	addresses.addArgument( 
    ['--count', "-c"],
    {
      action: 'store',
      type: Number,
      defaultValue: 10,
      help: 'List this many addresses each.',
    }
  )

  return parser
}
module.exports = {argParse, listOrders, startProc, startFork, dispListOrders, lockedAmount, addOrder, dispAddOrder, removeOrder, removeAllOrders}
