#!/usr/bin/env node
// Moving NODE_APP_INSTANCE aside during configuration loading
const BN = require('bignumber.js')
const Eth = require("@ledgerhq/hw-app-eth").default
const TransportNodeHid = require("@ledgerhq/hw-transport-node-hid-singleton").default
const chrono = require('chrono-node')
const columnify = require('columnify')
const dateFormat = require('dateformat')
const fs = require('fs')
const log4js = require('log4js')
const logger = require("@ledgerhq/logs");
const path = require('path')
const pm2 = require('pm2')
const pressAnyKey = require('press-any-key')
const {decimalToPrecision, TRUNCATE, DECIMAL_PLACES, PAD_WITH_ZERO, SIGNIFICANT_DIGITS} = require ('ccxt')
const {promisify} = require('es6-promisify')
const colors = require('colors')
const inquirer = require('inquirer')
const baseDir = __dirname + '/'
process.chdir(baseDir)

process.env.NODE_CONFIG_DIR = (process.env.NODE_CONFIG_DIR
  ?
    process.env.NODE_CONFIG_DIR + require('path').delimiter
  :
    "")
  + baseDir + "config/" + require('path').delimiter + baseDir + "config/secrets/" +
   require('path').delimiter + "config/radix/" 

const config = require('config')
const w3 = require('./utils/web3.js')
const ut = require('./utils/util')
const util = require('util')
const {argParse, web3MatchingCommands} = require('./utils/argparse.js')
const yaml = require('js-yaml')
const radix = require('./utils/radix.js')
const WalletConnect = require("@walletconnect/client").default


logger.listen(log => console.log(log.type + ": " + log.message))
BN.set({DECIMAL_PLACES: 45, ROUNDING_MODE: 1/*round down*/})

log4js.configure(
	{
		appenders: {
			out: {type: 'stdout', layout: {
				type: 'pattern',
				pattern: '%[[%d] [%p] [%f{1}#%l] -%] %m',
			},
			},
		},
		categories: {default: {appenders: ['out'], level: 'info', enableCallStack: true}},
	}
)

const log = log4js.getLogger()
log.level = config.get('loglevel')

if (process && (process.version < 'v15.0.0' || process.version.match(/^v\d\./))) {
	log.error('Please update nodejs to v15.0.0 or higher.')
	process.exit(1)
}

if (require.main === module) {
var args = argParse()
// if (!args.getYargsCompletions) console.log(args)
//fs.writeFileSync("/home/user/cceb/args.txt", JSON.stringify({args}));

let exchange
if ('exchange' === args._[0]) {
	const exchangeType = config.get(`keys.${args.exchange}.type`)
	if (exchangeType === 'centralized') {
		exchange = ut.getExchange(args.exchange)
	}
}

	(async () => {
		await processArgs(exchange, args)
})()
}

async function processArgs (exchange, args) {
	try {
		switch (args._[0]) {
			case 'exchange':
				switch (args._[1]) {
					case 'listorders':
						await dispListOrders(exchange, args, undefined)
						break
					case 'add':
						await dispAddOrder(exchange, args, undefined)
						break
					case 'rm':
						await removeOrder(exchange, args, undefined)
						break
					case 'rmall':
						await removeAllOrders(exchange, args, undefined)
						break
					case 'trickle':
						await dispAddTrickleOrder(exchange, args, undefined)
						break
					case 'markets':
						await dispMarkets(exchange, args)
						break
					case 'price':
						// TODO: implement dispPrice()
						// eslint-disable-next-line
						await dispPrice(exchange, args)
						break
					case 'orderbook':
						await dispOrderbook(exchange, args)
						break
					case 'withdraw':
						await withdraw(exchange, args)
						break
					case 'deposit':
						await dispDeposit(exchange, args)
						break
					case 'listbalances':
						await dispListBalances(exchange, args, null)
						break
				}
				break
			case 'eth':
        switch (args._[1]) {
					case 'tx':
						await dispEthTransaction(args)
						break
					case 'abi':
						await dispEthTransaction(args)
						break
					case 'source':
						await dispEthTransaction(args)
						break
					case 'send':
						await dispEthTransaction(args)
						break
					case 'address':
						await dispEthTransaction(args)
						break
					case 'import':
						await dispEthTransaction(args)
						break
					case 'nonce':
						await dispEthTransaction(args)
						break
					case 'web3':
						await dispEthTransaction(args)
						break
					case 'walletconnect':
						switch (args._[2]) {
							case 'connect':
								await displayConnect(args)
								break
						}
						break
					case 'maker':
						switch (args._[2]) {
							case 'info':
								await dispVaultInfo(args)
								break
							case 'open':
								await dispVaultOpen(args)
								break
							case 'deposit':
								await dispVaultDeposit(args)
								break
							case 'withdraw':
								await dispVaultWithdraw(args)
								break
							case 'generate':
								await dispVaultGenerate(args)
								break
							case 'payback':
								await dispVaultPayback(args)
								break
							case 'estimate':
								await dispVaultEstimate(args)
								// --Maker MKR acution commands ---
								break
							case 'auction':
								await dispFlop()
								break
							case 'tick':
								await dispTick(args)
								break
							case 'dent':
								await dispDent(args)
								break
							case 'deal':
								await dispDeal(args)
								break
							case 'flog':
								await dispFlog(args)
						} 
						break
					case 'aave':
						switch (args._[2]) {
							case 'deposit':
								await dispAaveDeposit(args.block, args.token, args.amount, args.from, args.gaslimit, args.gasprice, args.nonce)
								break
							case 'withdraw':
								await dispAaveWithdraw(args)
								break
							case 'collateral':
								await dispAaveCollateral(args.block, args.token, args.disable, args.from, args.gaslimit, args.gasprice, args.nonce)
								break
							case 'borrow':
								await dispAaveBorrow(args.amount, args.token, args.fixed, args.from, args.gasLimit, args.gasPrice, args.nonce)
								break
							case 'payback':
								await dispAavePayback(args)
								break
							case 'swaprate':
								await dispAaveSwapRate(args)
								break
							case 'rebalance':
								await dispAaveRebalance(args)
								break
							case 'liquidate':
								await dispAaveLiquidate(args)
								break
							case 'info':
								await dispAaveInfo(args)
								break
							case 'estimate':
								await dispAaveEstimate(args)
						}							
						break
					case 'curve':
						switch (args._[2]) {
							case 'info':
								await dispCurveInfo(args)
								break
						}
						break
				}
				break
			case 'ledger':
				switch (args._[1]) {
					case 'addresses':
						await dispLedgerAddresses(args)
						break
				}
				break
			case 'radix':
				await dispRadixCommand(args)
				break
		}
		process.exit(0)
	} catch (e) {
		log.error(e.stack)
		process.exit(1)
	}
}

async function displayConnect (args) {
	const {uri} = args

	log.info(`Connecting to ${uri}`)

	const walletConnect = new WalletConnect({
		uri,
    clientMeta: {
      description: "cceb wallet",
      url: "https://www.npmjs.com/package/cceb",
      icons: ["https://walletconnect.com/walletconnect-logo.png"],
      name: "cceb",
    },
	})


	walletConnect.on('session_request', async (error, payload) => {
		if (error) {
			log.error(error)
			return
		}
		log.info(`Session Request: ${JSON.stringify(payload, null, 2)}`)
		const accounts = await Promise.all(args.accounts.map(async account => await w3.getAddress(account)))

		console.log(`Session request: ${JSON.stringify(payload.params[0].peerMeta.url)}`)

		var result = {
			accounts,
			chainId: args.chainid || await getChainId(),
		}
		
		log.info(`Approve result sent: ${JSON.stringify(result)}`)

		walletConnect.approveSession(result)

		console.log(`Session Approved, accounts: ${accounts.join(', ')}`)

		process && process.on('SIGINT', async () => {
			log.info("Caught interrupt signal");
			await walletConnect.killSession()
			log.info("Session killed");
			walletConnect.transportClose()
			log.info("Transport closed");
			process.exit(0)
		});
	})

	walletConnect.on('call_request', async (error, payload) => {
		if (error) {
			log.error(error)
			return
		}
		log.info(`Call Request: ${JSON.stringify(payload)}`)
		

		var from 
		switch (payload.method) {
			case 'personal_sign':
				from = payload.params[1]
				break
			case 'eth_signTypedData':
			case 'eth_signTypedData_v4':
			case 'eth_sendRawTransaction':
			case 'eth_sign':
				from = payload.params[0]
				log.debug(`Signing message from ${from}`)
				break
			case 'eth_sendTransaction':
			case 'eth_signTransaction':
				from = payload.params[0].from
				log.debug(`Signing transaction from ${from}`)
				break
			default:
				log.error(`Unsupported method: ${payload.method}`)

				walletConnect.rejectRequest({
					id: payload.id,
					error: {
						code: -1,
						message: `Method ${payload.method} not found`,
					}})

				log.info(`Request rejected`)

				throw new Error(`Method ${payload.method} not found`)
		}

		const accounts = config.get(`web3.account`)
		log.trace(`Accounts: ${JSON.stringify(accounts)}`)

		const accountType = accounts[Object.keys(accounts).filter(key => accounts[key].address.toLowerCase() === from.toLowerCase())[0]].type
		var fn, result, signature, rawTx, txReceipt 
		switch (accountType) {
			case 'ledger':
				log.info(`Using Ledger account`)
				fn = w3.getLedgerSignature
				break
			case 'airsign':
				log.info(`Using Airsign account`)
				fn = w3.getAirsignSignature
				break
			case 'privatekey':
				log.info(`Using PrivateKey account`)
				fn = w3.getPrivateKeySignature
				break
			default:
				throw new Error(`Unknown account type: ${accountType}`)
		}

		switch (payload.method) {
			case 'personal_sign':
				console.log('from: ', from)
				console.log('msg: ', Buffer.from(payload.params[0]).toString())
				log.info(`Signing personal message`)
				from = payload.params[1]

				result = '0x' + (
					await getRes(
						'personal_sign',
						fn,
						{
							type: 'sign_personal_message',
							data: payload.params[0],
							from: payload.params[1]
						},
						walletConnect,
						payload
					)
				)
					.replace(/^\s*0x/, '')
					.replace(/[^A-Fa-f0-9]*$/, '')

				log.info(`Signature: ${result}`)
				approveRequest(walletConnect, payload, result)
				break
			case 'eth_sign':
				console.log('from: ', from)
				console.log('msg: ', Buffer.from(payload.params[0]).toString())
				log.info(`Signing message`)
				from = payload.params[1]

				result = '0x' + (
					await getRes(
						'eth_sign',
						fn,
						{
							type: 'sign_message',
							data: payload.params[1],
							from: payload.params[0]
						},
						walletConnect,
						payload
					)
				)
					.replace(/^\s*0x/, '')
					.replace(/[^A-Fa-f0-9]*$/, '')
				
				log.info(`Signature: ${result}`)

				approveRequest(walletConnect, payload, result)
				break
			case 'eth_signTypedData':
			case 'eth_signTypedData_v4':
				await visualizeTypedData(JSON.parse(payload.params[1]))
				log.info(`Signing typed data`)
				from = payload.params[0]
				
				result = '0x' + (
					await getRes(
					'eth_signTypedData',
					fn,
					{
						type: 'sign_typed_data',
						data: payload.params[1],
						from: payload.params[0],
						version: payload.method === 'eth_signTypedData_v4' ? 'V4' : 'V3'
					},
						walletConnect,
						payload
				)
				)
					.replace(/^\s*0x/, '')
					.replace(/[^A-Fa-f0-9]*$/, '')
				

				log.info(`Signature: ${result}`)
				approveRequest(walletConnect, payload, result)
				break
			case 'eth_sendTransaction':
				log.info(`Sending transaction`)
				from = payload.params[0].from

				try {
					result = (await w3.access(
						null,
						payload.params[0].to,
						null,
						null,
						null,
						args.overridefrom || payload.params[0].from,
						payload.params[0].value,
						args.overridegaslimit || args.theirgas && payload.params[0].gas,
						args.overridegasprice || args.theirgas && payload.params[0].gasPrice,
						args.overridenonce || payload.params[0].nonce,
						null,
						null,
						payload.params[0].data,
						args.gasoverhead,
						true 											// getHashFast
					)).transactionHash

					log.info(`Transactionhash: ${result}`)

					approveRequest(walletConnect, payload, result)

				} catch (e) {
					let message = `Signing aborted`
					log.error(`Error sending transaction: ${message} \n${e.stack}`)

					walletConnect.rejectRequest({
						id: payload.id,
						error: {
							code: -1,
							message,
						}
					})

					log.info(`Request rejected`)
				}

				break
			case 'eth_signTransaction':
				log.info(`Signing transaction`)
				from = payload.params[0].from

				signature = await getRes(
					'eth_signTransaction', 
					fn, 
					{
						type: 'sign_transaction',
						payload: payload.params[0],
						from: payload.params[0].from
					},
						walletConnect,
						payload
				)

				approveRequest(walletConnect, payload, signature)

				break	
			case 'eth_sendRawTransaction':
				log.info(`Sending raw transaction`)
				rawTx = payload.params[0]

				txReceipt = await getRes(
				'eth_sendRawTransaction',
					null,
					rawTx,
					walletConnect,
					payload
				)

				approveRequest(walletConnect, payload, txReceipt.transactionHash)

				break
			default:
				throw new Error(`Unknown method: ${payload.method}`)
	}
	})

	walletConnect.on('disconnect', (error, payload) => {
		log.info(`Got Disconnect`)
		if (error) {
			log.error(error)
			return
		}
		log.info(`Disconnected: ${JSON.stringify(payload)}`)

		process || process.exit(0)
	})

	// eslint-disable-next-line no-constant-condition
	while	(true) {
		await sleep(1000)
	}
}

async function visualizeTypedData (typedData) {

	colors.setTheme({
		silly: 'rainbow',
		input: 'grey',
		verbose: 'cyan',
		prompt: 'grey',
		info: 'green', //'white',
		data: 'grey', //'grey',
		help: 'cyan',
		warn: 'yellow', //'yellow',
		debug: 'blue',
		error: 'red'
	})

	const sanitizedTypedData = w3.sigUtil.TypedDataUtils.sanitizeData(typedData)
	log.info(`Sanitized typed data: ${JSON.stringify(sanitizedTypedData)}`)

	console.log(`typed data:`.info)
	console.log(`	domain:`.info)
	for (const i in sanitizedTypedData.domain) {
		log.info(`		${i}: ${sanitizedTypedData.domain[i]}`)
		var dis = sanitizedTypedData.domain[i]
		var disType = sanitizedTypedData.types.EIP712Domain.find(entry => entry.name === i).type 
		switch (disType) {
			case 'string':
				console.log(`		${i}: `.info + `"${dis}"`.data)
				break
			case 'address':
				dis = await w3.getAddressName(dis)
				console.log(`		${i}: `.info + `${dis}`.data)
				if (dis.match(/^\s*0x[a-fA-F0-9]*\s*$/)) {
					await inquireAddress(dis)
				} 
				break
			default:
				if (disType.match(/uint\d+/)) {
					console.log(`		${i}: `.info + `${dis}`.data)
				} else {
					throw new Error(`Unknown type: ${disType}`)
				}
		}
	}
	console.log(`	message:`.info)
  await displayMessageItem(2, sanitizedTypedData.primaryType, sanitizedTypedData,  sanitizedTypedData.message)
}

async function displayMessageItem (depth, parentTypeName, sanitizedTypedData, dispObject) {
	for (var name in dispObject) {
		if (typeof dispObject[name] === 'object') {
			// type is object
			console.log(`${' '.repeat(depth)}${name}:`.info)
			await displayMessageItem(depth + 1, name, sanitizedTypedData, dispObject[name])
			continue
		} 

		// get value
		const value = dispObject[name]

		// get type of value
		var type = sanitizedTypedData.types[parentTypeName].find(entry => entry.name === name).type
		switch (type) {
			case 'string':
			case 'bytes':
				console.log(`${"	".repeat(depth) + name}: `.info + `"${value}"`.data)
				break
			case 'address':
				console.log(`${"	".repeat(depth) + name}: `.info + `${await w3.getAddressName(value)}`.data)
				break
			default:
				if (type.match(/uint\d*/)) {
					console.log(`${"	".repeat(depth) + name}: `.info + `${value}`.data)
				} else {
					console.log(`${"	".repeat(depth) + name}: `.warn + `"${value}"`.warn)
				}
		}

	}

}

async function inquireAddress (address) {
	let accept = await inquirer.prompt([{
		type: 'list',
		name: 'accept',
		message: `${address} is not recognized address. This can be a FRAUD!! What do you want to do?`,
		choices: [
			'Import address',
			'Accept address',
			'Reject signature',
			'Cancel',
		]}])

	let im, args
	switch (accept.accept) {
		case 'Import address':
			im = await inquirer.prompt([{
				type: 'input',
				name: 'address',
				message: `Enter address name import to: (use upper case letters and underscore)`,
				validate (value) {
					if (value.match(/^\s*[A-F0-9][A-F0-9_]*\s*$/)) {
						return true
					} else {
						return 'Please enter valid address name'
					}
				}

			},
				{
					type: 'input',
					name: 'importpath',
					message: `Enter address path import to: (eg.: web3.mainnet.token) leave empty for default)`,
					validate (value) {
						let accepted = new RegExp(`^\\s*web3\\.(mainnet|ropsten|rinkeby|kovan)\\.\\w+\\s*$`)
						if (value.match(accepted)) {
							return true
						} else {
							return 'Please enter valid address path'
						}
					}
				}])

			args = {contractName: im.address, contractAddress: address, location: im.importpath}
			await w3.importAddress(args)
			break
		case 'Accept address':
			break
		case 'Reject signature':
		case 'Cancel':
			throw new Error('Signature rejected')
		default:
			throw new Error('Unknown option')
	}
}

async function getRes (type, fn, arg, walletConnect, payload) {
	try {
		switch (type) {
			case 'eth_sendRawTransaction':
				log.info(`Sending raw transaction: ${JSON.stringify(arg)}`)
				return await w3.web3.eth.sendSignedTransaction(arg).on('error', console.error)
			default:
				try {
					return await fn(arg, arg.type)
				} catch (e) {
					log.error(`Rejected ${type}: ${JSON.stringify(arg)}`)

					walletConnect.rejectRequest({
						id: payload.id,
						error: {
							code: e.code,
							message: e.message,
						}
					})

					log.info(`Request rejected`)
				}
		}
	} catch (e) {
		log.error(`Rejected raw transaction: ${JSON.stringify(arg)}`)

		walletConnect.rejectRequest({
			id: payload.id,
			error: {
				code: e.code,
				message: e.message,
			}
		})

		log.info(`Request rejected`)
	}
}

function approveRequest (walletConnect, payload, result) {

				let approved = {
					id: payload.id,
					jsonrpc: payload.jsonrpc,
					result,
				}

				log.debug(`approved: ${JSON.stringify(approved)}`)

				walletConnect.approveRequest(approved)

				log.info(`Request approved`)
}

async function dispRadixCommand (args) {
	//console.log(args)

	const parameters = Object.keys(args)
		.filter(param => param.match(/^[a-z0-9]/))
		.reduce((params, param) => {
			params[param] = args[param] 
			return params
		}, {})

	const result = await radix.queryRpc(args._[1], parameters )
	console.log(yaml.dump(result))
}

async function dispLedgerAddresses (args) {
	const addresses = await ledgerAddresses(args)
	Object.keys(addresses).map(key => addresses[key].map(desc => console.log(`${key}: ${desc.address} derivePath: ${desc.derivePath}`)))
}
	
async function ledgerAddresses (args) {
	switch (args.wallet) {
		case "Ethereum":
			console.log(await TransportNodeHid.list())
			// eslint-disable-next-line
			const transport = await TransportNodeHid.create();
			// eslint-disable-next-line
			const eth = new Eth(transport)

			var addressLoc = Array.from(Array(args.count).keys())
				.map(idx => idx + args.startPosition)

			var live = await addressLoc.reduce(async (acc, loc) => {
							const results = await acc
							const derivePath = `44'/60'/${loc}'/0/0`
							return [
								...results,
								{
									address: (await eth.getAddress(derivePath)).address,
									derivePath
								}
							]
					}, []
					)

			var legacy = await addressLoc.reduce(async (acc, loc) => {
							const results = await acc
							const derivePath = `44'/60'/0'/${loc}`
							return [
								...results,
								{
									address: (await eth.getAddress(derivePath)).address,
									derivePath
								}
							]
					}, []
					)

			return {live, legacy}
	default:
			throw new Error(`Wallet ${args.wallet} not implemented yet.`)
	}
}

async function dispCurveInfo (args) {
	const {claims, crv_day, sum, crv_usd, lp_usd, gauge_percent, deposit_token} = await curveInfo(args)

	var render = claims
		.map(gauge => {return {
			gauge: gauge.gauge,                                   // name of gauge
			crv: BN(gauge.token).div(10**18).toFixed(2),          // current crv balance
			crv_usd: BN(gauge.crv_usd).div(10**6).toFixed(2),     // current crv balance in usd
			crv_100k: BN(gauge.crv_100k).div(10**18).toFixed(2),  // crv daily harvest per 100k lp token (good to compare pools)
			crv_100k_f: BN(gauge.crv_100k_f).div(10**18).toFixed(2),  // crv daily harvest per 100k lp token (good to compare pools)
			crv_day: BN(gauge.crv_day).div(10**18).toFixed(2),    // crv daily harvest per current lp token deposit
			lp: BN(gauge.lp).div(10**18).toFixed(2),              // lp tokens deposited
			lp_usd: gauge.lp_usd.toFixed(2),                      // usd value of lp tokens deposited
			boost: gauge.boost.toFixed(2),                        // current boost
			boost_f: BN( gauge.boost_f).toFixed(2),               // future boost if same lp tokens would be deposited now
			d_lp_max_boost: gauge.d_lp_max_boost.div(10**18).toFixed(2),   // this much lp tokens can be deposited without loosing max boost
			gauge_percent: gauge.gauge_percent.times(100)
			.toFixed(2),                                       // this is percentage of CRV that ends up in gauge 
			deposit_usd: gauge.deposit_token.toFormat(2), // deposited USD value in gauge 
		}})
		.sort((a, b) => Number(a.crv_100k) - Number(b.crv_100k))

	render.push({
		gauge: '---',
		crv: '---',
		crv_usd: '---',
		gauge_percent: '---',
		deposit_usd: '---',
		crv_100k: '---',
		crv_100k_f: '---',
		crv_day: '---',
		lp: '---',
		lp_usd: '---',
		boost: '---',
		boost_f: '---',
		d_lp_max_boost: '---',
	})

	render.push({
		gauge: 'TOTAL',
		crv: BN(sum).div(10**18).toFixed(2),
		crv_usd: crv_usd.div(10**6).toFixed(2),
		crv_100k: '',
		crv_100k_f: '',
		crv_day: BN(crv_day).div(10**18).toFixed(2),
		lp: '',
		lp_usd: lp_usd.toFixed(2),
		boost: '',
		boost_f: '',
		d_lp_max_boost: '',
		gauge_percent: gauge_percent.toFixed(2),
		deposit_usd: deposit_token.toFormat(2),
	})

	const columns = columnify(render,
		{config: {
			gauge: {align: 'left'},
			crv: {align: 'right'},
			crv_usd: {align: 'right'},
			crv_100k: {align: 'right'},
			crv_100k_f: {align: 'right'},
			crv_day: {align: 'right'},
			sum: {align: 'right'},
			lp: {align: 'right'},
			lp_usd: {align: 'right'},
			boost: {align: 'right'},
			boost_f: {align: 'right'},
			d_lp_max_boost: {align: 'right'},
			gauge_percent: {align: 'right'},
			deposit_usd: {align: 'right'},
		}})

	console.log(columns)
}

async function curveInfo (args) {
	var fileNames = await fs.promises.readdir(baseDir + 'abi')
	fileNames = fileNames.filter(fileName => /^CRV_GAUGE_/.test(fileName) && fileName !== 'CRV_GAUGE_CONTROLLER')

	var claims = await Promise.all(fileNames.map(async fileName => {
		return { 
			gauge: fileName, 
			token: await w3.access(args.block, fileName, 'claimable_tokens', [args.from]),
			lp_free: await w3.access(args.block, 'CRV_LP_' + fileName.replace(/CRV_GAUGE_/, ''), 'balanceOf', [args.from]),
		}
	}
	)
	)

	claims.map(gauge => {
		BN(gauge.lp_free).gt(1) && log.warn(`${gauge.gauge} has unused LP of ${BN(gauge.lp_free).toFixed()}`)
		return 0
	})

	// claims = claims.filter(gauge => gauge.token !== '0')
	const ve_crv = await w3.access(args.block, 'CRV_VECRV', 'balanceOf', [args.from])
	const ve_crv_total = await w3.access(args.block, 'CRV_VECRV', 'totalSupply')
	// const WEEK = 604800
	const rate = await w3.access(args.block, 'CRV', 'rate')
	const btc_usd = (await w3.access(args.block, 'UNISWAP_ROUTER_V2', 'getAmountsOut', ["1.00000000", ["WBTC", "WETH", "USDT"]]))[2]

	claims = await Promise.all(claims.map(async claim => {
		// const period = await w3.access(args.block, claim.gauge,'period')
		// const prev_week_time = await w3.access(args.block, claim.gauge,'period_timestamp',[period])
		const crv_usd = claim.token !== '0' ? (await w3.access(args.block, 'UNISWAP_ROUTER_V2', 'getAmountsOut', [claim.token, ["CRV", "WETH", "USDT"]]))[2]: 0
		const lp = await w3.access(args.block, claim.gauge, 'balanceOf', [args.from])
		const name = claim.gauge.replace(/CRV_GAUGE_/, '')
		const lp_virtual_price = await w3.access(args.block, 'CRV_SWAP_' + name, 'get_virtual_price')
		const lp_usd = BN(lp).times(BN(lp_virtual_price)).div(10**36)
		const lp_total = (await w3.access(args.block, claim.gauge, 'totalSupply')).replace(/\./, "")
		const lp_all = (await w3.access(args.block, 'CRV_LP_' + name, 'totalSupply')).replace(/\./, "")
		var deposit_token = BN(lp_all).times(BN(lp_virtual_price)).div(10**36)
		if (/.*BTC.*|.*REN.*/.test(claim.gauge)) {
			deposit_token = deposit_token.times(BN(btc_usd)).div(10**6)
		}
		const working_balances =  await w3.access(args.block, claim.gauge, 'working_balances', [args.from])
		const working_supply =  await w3.access(args.block, claim.gauge, 'working_supply')
		const gauge_relative_weight = await w3.access(args.block, 'CRV_GAUGE_CONTROLLER', 'gauge_relative_weight', [claim.gauge]) 
		const next_week = String(Math.floor(Date.now() / 1000 + 604800))
		const gauge_relative_weight_f = await w3.access(args.block, 'CRV_GAUGE_CONTROLLER', 'gauge_relative_weight', [claim.gauge, next_week]) 
		const gauge_weight = await w3.access(args.block, 'CRV_GAUGE_CONTROLLER', 'get_gauge_weight', [claim.gauge]) 
		const gauge_type = await w3.access(args.block, 'CRV_GAUGE_CONTROLLER', 'gauge_types', [claim.gauge]) 
		const type_weight = await w3.access(args.block, 'CRV_GAUGE_CONTROLLER', 'get_weights_sum_per_type', [gauge_type]) 
		const gauge_percent = BN(gauge_weight).div(BN(type_weight))
		const crv_day_lp = BN(rate).times(BN(gauge_relative_weight)).times(86400).div(BN(working_supply))
		const crv_day_lp_f = BN(rate).times(BN(gauge_relative_weight_f)).times(86400).div(BN(working_supply))
		const crv_100k = crv_day_lp.times(100000)
		const crv_100k_f = crv_day_lp_f.times(100000)
		const boost = BN(working_balances).div(BN(lp)).times(2.5)
		const crv_day = lp === '0' ? BN(0) : crv_day_lp.times(BN(lp)).div(10**18).times(boost).div(2.5)

		const boost_f = 
			Math.min(
				Number(
					BN(lp)
					.times(0.4)
					.plus(
						BN(lp_total)
						.times(
							BN(ve_crv)
							.div( BN(ve_crv_total))
						)
						.times(0.6)
					)
					.div(BN(lp))
					.times(2.5)),
				2.5)

		const d_lp_max_boost = BN(lp_total).times(BN(ve_crv).div(BN(ve_crv_total))).minus(BN(lp))
		return {
			...claim,
			crv_usd,
			gauge_percent,
			lp,
			lp_usd,
			lp_total,
			deposit_token,
			working_balances,
			crv_day_lp, 
			crv_100k, 
			crv_100k_f, 
			crv_day,
			boost, 
			boost_f, 
			d_lp_max_boost, 
		}   
	}))

	claims = claims
		.reduce((acc, val, idx) => {
			acc.push({...val, sum: new BN(val.token).plus((acc[idx-1] && BN(acc[idx-1].sum)||'0')).toFixed()})
			return acc}, [])

	const crv_day = claims.reduce((acc, val) => val.crv_day.plus(acc), BN(0)) 
	const sum = claims[claims.length - 1]['sum']
	const crv_usd = claims.reduce((acc, val) => BN(val.crv_usd).plus(acc), BN(0))
	const lp_usd = claims.reduce((acc, val) => BN(val.lp_usd).plus(acc), BN(0))
	const gauge_percent = claims.reduce((acc, val) => BN(val.gauge_percent).plus(acc), BN(0)).times(100)
	const deposit_token = claims.reduce((acc, val) => BN(val.deposit_token).plus(acc), BN(0))
	return {claims, crv_day, sum, crv_usd, lp_usd, gauge_percent, deposit_token}
}

async function dispAaveDeposit (block, token, amount, from, gaslimit, gasprice, nonce) {
	console.log(await aaveDeposit(block, token, amount, from, gaslimit, gasprice, nonce))
}

async function getChainId () {
	const network = config.get('web3.network')
	return config.get(`web3.${network}.chainid`)
}

async function getReferralCode () {
	const network = config.get('web3.network')
	return config.get(`web3.${network}.aave.referralCode`)
}

async function aaveDeposit (block, token, amount, from, gaslimit, gasprice, nonce) {
	const decimals = token === 'ETH' ? 18 : Number(await w3.decimals(block, token))
	const depositAmt = BN(amount).times(BN(10).pow(decimals)).integerValue()
	const referralCode = await getReferralCode()
	const lendingPool = await w3.access(block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	const lendingPoolCore = await w3.access(block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPoolCore')
	var approved
	if (token === 'ETH') {
		approved = BN(10).pow(100)	
		token = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'
	} else {
		approved = BN(await w3.access(block, token, 'allowance', [from, lendingPoolCore], 'ERC20'))
	}

	
	if (approved.lt(depositAmt)) {
		await w3.access(
			block,
			token,
			'approve',
			[lendingPoolCore, '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'],
			'ERC20',
			from,
			null,
			gaslimit,
			gasprice,
			nonce
			)
	}

	await w3.access(
		block,
		lendingPool,
		'deposit',
		[
			token,
			depositAmt.toFixed(),
			referralCode
		],
		'AAVE_LENDING_POOL',
		from,
		(token === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? depositAmt.toFixed() : 0),
		gaslimit,
		gasprice,
		nonce)
		

	return ''

}

async function dispAaveWithdraw (args) {
	console.log(await aaveWithdraw(args))
}

async function aaveWithdraw (args) {
	const aToken = 'a' + args.token
	const decimals = Number(await w3.decimals(args.block, aToken))
	var amount
	if (args.amount.match(/ALL/i)) {
		amount = BN(await w3.access(args.block, aToken, 'balanceOf', [args.from], 'ERC20'))
	} else {
		amount = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	}
	var canWithdraw = await w3.access(args.block, aToken, 'isTransferAllowed', [args.from, amount], 'aToken')
	if (!canWithdraw) { throw new Error('Withdraw not possible. Payback all debt first!')}
	log.debug(`amount final: ${amount.toFixed()}`)

	await w3.access(
	args.block,
	aToken,
		'redeem',
		[amount.toFixed()],
		'aToken',
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	) 
}

async function dispAaveCollateral (block, token, disable, from, gaslimit, gasprice, nonce) {
	console.log(await aaveCollateral(block, token, disable, from, gaslimit, gasprice, nonce))
}

async function aaveCollateral (block, token, disable, from, gaslimit, gasprice, nonce) {
	if (token === 'ETH') {
		token = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'
	} 
	const lendingPool = await w3.access(block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	return await w3.access(block, lendingPool, 'setUserUseReserveAsCollateral', [token, !disable], 'AAVE_LENDING_POOL', from, null, gaslimit, gasprice, nonce)
}

async function dispAaveBorrow (amount, token, fixed, from, gasLimit, gasPrice, nonce) {
	console.log(await aaveBorrow(amount, token, fixed, from, gasLimit, gasPrice, nonce))
}

async function aaveBorrow (
	amount,
	token,
	fixed,
	from,
	gasLimit,
	gasPrice,
	nonce,
	block
) {
	const decimals = token === 'ETH' ? 18 : Number(await w3.decimals(block, token))
	const borrowAmt = BN(amount).times(BN(10).pow(decimals)).integerValue()
	const interestRateMode = fixed ? 1 : 2
	const referralCode = await getReferralCode()
	const lendingPool = await w3.access(block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	return await w3.access(block, lendingPool, 'borrow', [token, borrowAmt.toFixed(), interestRateMode, referralCode], 'AAVE_LENDING_POOL', from, 0, gasLimit, gasPrice, nonce)
}

async function dispAavePayback (args) {
	console.log(await aavePayback(args))
}

async function aavePayback (args) {
	
	const decimals = 
		args.token === 'ETH' ?
		18 :
		Number(await w3.decimals(args.block, args.token))

	if ( args.amount.match(/all/i)) {

		if (args.token === 'ETH') {
			var {currentBorrowBalance:paybackAmt} = await aaveInfo({...args, aaveInfoCommand: 'user'})

			paybackAmt = BN(paybackAmt).plus(BN(config.get('web3.aave.paybackExtra')).times(BN(10).pow(18))).toFixed()
		} else {
			paybackAmt = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
		}
	} else {

		paybackAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue().toFixed()
	
	}
	
	const lendingPoolCore = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPoolCore')
	
	const approved = args.token === 'ETH' ?
		BN(10).pow(100) :
		BN(await w3.access(
			args.block,
			args.token,
			'allowance',
			[args.from, lendingPoolCore],
			'ERC20'
		))
	
	if (approved.lt(paybackAmt)) {
		await w3.access(
			args.block,
			args.token,
			'approve',
			[lendingPoolCore, '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'],
			'ERC20',
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
		)
	}
	const lendingPool = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
	args.block,
	lendingPool,
		'repay',
		[
			args.token,
			paybackAmt,
			args.for ? args.for : args.from
		],
		'AAVE_LENDING_POOL',
		args.from,
		(args.token === 'ETH' ? paybackAmt : 0),
		args.gaslimit,
		args.gasprice,
		args.nonce
		)
}

async function dispAaveSwapRate (args) {
	console.log(await aaveSwapRate(args))
}

async function aaveSwapRate (args) {
	const lendingPool = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
		args.block,
		lendingPool,
		'swapBorrowRateMode',
		[args.token],
		'AAVE_LENDING_POOL',
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)
}

async function dispAaveRebalance (args) {
	console.log(await aaveRebalance(args))
}

async function aaveRebalance (args) {
	
	const lendingPool = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')

	await w3.access(
		args.block,
		lendingPool,
		'rebalanceStableBorrowRate',
		[args.token, args.for ? args.for : args.from],
		'AAVE_LENDING_POOL',
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)
}

async function dispAaveLiquidate (args) {
	console.log(await aaveLiquidate(args))
}

async function aaveLiquidate (args) { //TODO: implement

	const lendingPool = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	
	await w3.access(
		args.block,
		lendingPool,
		'liquidationCall', 
		[
			args.token, 
			args.for ? args.for : args.from
		],
		'AAVE_LENDING_POOL',
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
		)//TODO: finish arguments
}

async function dispAaveInfo (args) {
	console.log(await aaveInfo(args))
}

async function aaveInfo (args) {
	const lendingPool = await w3.access(args.block, 'AAVE_LENDING_POOL_ADDRESSES_PROVIDER', 'getLendingPool')
	
	if (args._[3] === 'reserve') {

		var configdata =  await w3.access(
			args.block,
			lendingPool,
			'getReserveConfigurationData',
			[args.token],
			'AAVE_LENDING_POOL'
		)
	
		var configdata1 = await w3.access(args.block, lendingPool, 'getReserveData', [args.token], 'AAVE_LENDING_POOL')	

		return {...configdata, ...configdata1}
	
	}	else if (args._[3] === 'account') {
		
		return await w3.access(args.block, lendingPool, 'getUserAccountData', [args.from], 'AAVE_LENDING_POOL')		
	
	}	else if (args._[3] === 'user') {
	
		return await w3.access(args.block, lendingPool, 'getUserReserveData', [args.token, args.from], 'AAVE_LENDING_POOL')		
	}
}

async function dispAaveEstimate (args) {
	console.log(await aaveEstimate(args))
}

async function aaveEstimate () {
}

//---------------------
async function dispVaultEstimate () {
	console.log((await vaultEstimate()).toString())
}

async function vaultEstimate () {
	var gas = 739549
	return await estimateGasCost(gas)
}

async function dispVaultPayback (args) {
	console.log(await vaultPayback(args))
}

async function vaultPayback (args) {
	if (args.estimate) {
		var gas = 159676
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	var {vaultAddr, vaultTypeHex, daiNormalized} = await getUrnParams(vaultId, args.type)

	var ilk = await w3.access(args.block, 'MCD_VAT', 'ilks', [vaultTypeHex]) 
	var rate = BN(ilk.rate)
	log.debug(`rate: ${rate}`)
	
	var daiVault = BN(await w3.access(args.block, 'MCD_VAT', 'dai', [vaultAddr]))
	log.debug(`dai in Vault: ${daiVault.toFixed()}`)
	const daiBalance = BN(await w3.access(args.block, 'MCD_DAI', 'balanceOf', [args.from], 'ERC20'))
	var daiVaultNormalizedWad = daiVault.div(rate).integerValue()
	log.debug(`dai in Vaultnormalized: ${daiVaultNormalizedWad.toFixed()}`)
	var paybackWad = BN(args.amount).times(BN(10).pow(18)).integerValue()
	log.debug(`paybackWad(before leftover payback): ${paybackWad.toFixed()}`)
	paybackWad = paybackWad.minus(daiVault.div(BN(10).pow(27)).integerValue())
	log.debug(`paybackWad(after leftover payback): ${paybackWad.toFixed()}`)
	paybackWad = BN.min(paybackWad, daiNormalized.times(rate).div(BN(10).pow(27)).integerValue().plus(1), daiBalance)
	log.debug(`paybackWad(after considering actual dai debt, and balance): ${paybackWad.toFixed()}`)
	const paybackNormalizedWad = paybackWad.times(BN(10).pow(27)).div(rate).integerValue()

	log.debug(`paybackNormalizedWad: ${paybackNormalizedWad}`)
	const approvedDai = BN(await w3.access(args.block, 'MCD_DAI', 'allowance', [args.from, 'MCD_JOIN_DAI'], 'ERC20'))
	if (approvedDai.lt(paybackWad)) {
		await w3.access(
			args.block,
			'MCD_DAI',
			'approve',
			['MCD_JOIN_DAI', '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'],
			'ERC20',
			args.from,
			0, 
			args.gaslimit,
			args.gasprice,
			args.nonce
		)	
	}
	if (paybackWad.gt(0)) {
		await w3.access(
			args.block,
			'MCD_JOIN_DAI',
			'join',
			[vaultAddr, paybackWad.toFixed()],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
			)
		
	}
	
	daiVault = BN(await w3.access(args.block, 'MCD_VAT', 'dai', [vaultAddr])).div(BN(10).pow(27))
	ilk = await w3.access(args.block, 'MCD_VAT', 'ilks', [vaultTypeHex]) 
	rate = BN(ilk.rate)
	log.debug(`rate: ${rate}`)
	daiVaultNormalizedWad = daiVault.div(rate).integerValue()

	await w3.access(
		args.block,
		'MCD_CDP_MANAGER',
		'frob',
		[vaultId, '0', daiVaultNormalizedWad],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
		) //FIXME: withdraw collateral too
}

async function dispVaultGenerate (args) {
	console.log(await vaultGenerate(args))
}

async function vaultGenerate (args) {
	w3.web3.eth.handleRevert = true
	if (args.estimate) {
		var gas = 208114
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const vaultAddr = await w3.access(args.block, 'MCD_CDP_MANAGER', 'urns', [vaultId])
	var ilk = await w3.access(args.block, 'MCD_VAT', 'ilks', [vaultTypeHex]) 
	var rate = new BN(ilk.rate)
	var daiToGenerate = BN(args.amount).times(BN(10).pow(45)).integerValue()
	log.debug(`DaiToGenerate: ${daiToGenerate}`)
	var daiAtVault = BN(await w3.access(args.block, 'MCD_VAT', 'dai', [vaultAddr]))
	log.debug(`daiAtVault: ${daiAtVault}`)
	var daiAtFrom = BN(await w3.access(args.block, 'MCD_VAT', 'dai', [args.from]))
	var daiTotal = daiAtVault.plus(daiAtFrom)
	log.debug(`daiAtFrom: ${daiAtFrom}`)
	var daiToFrobWad = (daiTotal.lt(daiToGenerate) ? daiToGenerate.minus(daiTotal) : BN(0)).div(rate).integerValue()
	log.debug(`DaiToFrobWad: ${daiToFrobWad}`)
	if (!daiToFrobWad.eq(BN(0))) {

		await w3.access(
			args.block,
			'MCD_CDP_MANAGER',
			'frob',
			[vaultId, 0, daiToFrobWad.toFixed()],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
			)

		daiAtVault = BN(await w3.access(args.block, 'MCD_VAT', 'dai', [vaultAddr]))
		daiTotal = daiAtVault.plus(daiAtFrom)
	}

	daiToGenerate = BN.min(daiToGenerate, daiTotal)
	
	await w3.access(
		args.block,
		'MCD_CDP_MANAGER',
		'move',
		[vaultId, args.from, daiToGenerate.minus(daiAtFrom).integerValue().toFixed()],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)

	const joinEnabled = await w3.access(args.block, 'MCD_VAT', 'can', [args.from, 'MCD_JOIN_DAI'])
	
	if (Number(joinEnabled) === 0) {
		await w3.access(
			args.block,
			'MCD_VAT',
			'hope',
			['MCD_JOIN_DAI'],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
		)
	}

	await w3.access(
		args.block,
		'MCD_JOIN_DAI',
		'exit',
		[args.from, daiToGenerate.div(BN(10).pow(27)).integerValue().toFixed()],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)
}

async function dispVaultWithdraw (args) {
	await vaultWithDraw(args)
}

async function vaultWithDraw (args) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var collCoin = args.type.replace(/-.*/, '')
	if (args.estimate) {
		var gas = 225226
		if (collCoin === 'ETH') gas += 38169
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	if (collCoin === 'ETH') collCoin = 'WETH'
	const joinContract = 'MCD_JOIN_' + args.type.replace(/-/, "_")
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const decimals = Number(await w3.decimals(args.block, collCoin))
	var withdrawAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	var withdrawAmtWad = BN(args.amount).times(BN(10).pow(18)).integerValue()
	
	const vltInfo = await vaultInfo(args)
	const vault = vltInfo.find(vlt => vlt.vaultId.eq(vaultId))
	if (vault.collateralToWithdraw.lt(args.amount)) {
		throw Error(`You can't withdraw more than ${vault.collateralToWithdraw}. Or pay back some DAI first!`)
	}
	if (vault.unlockedCollateral.lt(args.amount)) {
		const freeCollateral = vault.unlockedCollateral.minus(args.amount).times(BN(10).pow(18)).integerValue()

		await w3.access(
			args.block,
			'MCD_CDP_MANAGER',
			'frob',
			[vaultId, freeCollateral.toFixed(), 0],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
		) //FIXME: allow to payback dai
	}

	await w3.access(
		args.block,
		'MCD_CDP_MANAGER',
		'flux',
		[vaultId, args.from, withdrawAmtWad.toFixed()],
		null,
		args.from, 
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce,
		['uint256', 'address', 'uint256']
	)
	
	await w3.access(
		args.block,
		joinContract,
		'exit',
		[args.from, withdrawAmt.toFixed()],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)
	
	if (collCoin === 'WETH') {
		await w3.access(
			args.block,
			'WETH',
			'withdraw',
			[withdrawAmt.toFixed()],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
		)
	}
}

async function dispVaultDeposit (args) {
	console.log(await vaultDeposit(args))
}

async function vaultDeposit (args) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))
	var collCoin = args.type.replace(/-.*/, '')
	if (args.estimate) {
		var gas = 146533
		if (collCoin === 'ETH') gas += 43766
		console.log(await estimateGasCost(gas))
		process.exit(0)
	}
	if (collCoin === 'ETH') {
		collCoin = 'WETH'

		await w3.access(
			args.block,
			'WETH',
			'deposit',
			[],
			null,
			args.from,
			BN(args.amount).times(BN(10).pow(18)).integerValue().toFixed(),
			args.gaslimit,
			args.gasprice,
			args.nonce
		)
	}
	const joinContract = 'MCD_JOIN_' + args.type.replace(/-/, "_")
	const decimals = Number(await w3.decimals(args.block, collCoin))
		var allowance = BN(await w3.access(args.block, collCoin, 'allowance', [args.from, joinContract]))
		if (allowance.div(BN(10).pow(decimals)).lt(BN(args.amount))) {
			//if allowance less than amount to deposit
			log.info("approve infinite")

			await w3.access(
				args.block,
				collCoin, 
				'approve', 
				[
					joinContract,
					'0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
				],
				null,
				args.from,
				0,
				args.gaslimit,
				args.gasprice,
				args.nonce
			)
		}
	var balance = BN(await w3.access(args.block, collCoin, 'balanceOf', [args.from]))
	var {vaultId} = await getVaultId(args.from, args.vault, vaultTypeHex)
	const vaultAddr = await w3.access(args.block, 'MCD_CDP_MANAGER', 'urns', [vaultId])
	var depositAmt = BN(args.amount).times(BN(10).pow(decimals)).integerValue()
	if (depositAmt.gt(balance)) {
		depositAmt = balance
		log.warn("Deposit truncated to: " + balance.div(BN(10).pow(decimals)).integerValue().toFixed())
	}

	log.info(`joincontract: ${joinContract} vaultAddr: ${vaultAddr} depositamt: ${depositAmt.toFixed()}`)

	await w3.access(
		args.block,
		joinContract,
		'join',
		[vaultAddr, depositAmt.toFixed()],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)

	const depositInt = await w3.web3.eth.abi.encodeParameter('int', depositAmt.toFixed())
		var ilk = await w3.access(args.block, 'MCD_VAT', 'ilks', [vaultTypeHex], null, args.from) 
		var rate = new BN(ilk.rate)
	const drawDaiInt = await w3.web3.eth.abi.encodeParameter('int', BN(args.draw).times(BN(10).pow(18+27)).div(rate).integerValue().toFixed())

	await w3.access(
		args.block,
		'MCD_CDP_MANAGER', 
		'frob',
		[vaultId, depositInt, drawDaiInt],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
	)
}

async function dispVaultOpen (args) {
	console.log(await vaultOpen(args))
}

async function estimateGasCost (gas) {
	var price = await getPriceInOtherCurrency('coinbasepro', 'ETH', 'USD')
	var gasPrice = BN(await w3.getGasPrice())
	const total = gasPrice.times(price).times(gas).div(BN(10).pow(18)).toFixed()
	return total
}

async function vaultOpen (args) {
	if (args.estimate) {
		console.log(await estimateGasCost(229642))
		process.exit(0)
	}

	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(args.type).toString('hex'))

	await w3.access(
		args.block,
		'MCD_CDP_MANAGER',
		'open',
		[vaultTypeHex, args.from],
		null,
		args.from,
		0,
		args.gaslimit,
		args.gasprice,
		args.nonce
		)

	return await w3.access(args.block, 'MCD_CDP_MANAGER', 'last', [args.from])
}

async function dispVaultInfo (args) {
	// get dai debt from vat contract
	const vltInfo = await vaultInfo(args)
	const collCoin = args.type.replace(/-.*/, '')

	vltInfo.map(vault => console.log(
		"id:" + vault.vaultId.toFixed() +
		"\nproxy: " + (vault.proxyUsed ? "true" : "false") +
		`\nfrom: ${vault.fromAddr}\
		\nvault: ${vault.vaultAddr}\
		\ndeposit: ${vault.deposit.toFixed()} ${collCoin}\
		\ndebt: ${vault.debt.toFixed()}\
		\ndaiToGenerate: ${vault.daiToGenerate.toFixed()}\
		\ncollateralToWithdraw: ${vault.collateralToWithdraw.toFixed()}\
		\nliquidationRatio: ${vault.liquidationRatio.toFixed()}\
		\nfeed: ${vault.priceFeedAddress}`
	))
}

async function getVaultId (from, vault, type) {
	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(type).toString('hex'))
	// check if cdp is registered with proxy
	var proxyAddress = await w3.access(args.block,  'MCD_PROXY_REGISTRY', 'proxies', [from])
	var fromAddress = parseInt(proxyAddress) === 0 ? from : proxyAddress

	log.info(`fromAddress: ${fromAddress}, type: ${typeof fromAddress}`)
	
	var vaultId = vault !== 0 ? vault : await w3.access(args.block, 'MCD_CDP_MANAGER', 'last', [fromAddress])
	log.debug({vaultId})
	if (vaultTypeHex) {
		var vaultTypeHexCurr = await w3.access(args.block, 'MCD_CDP_MANAGER', 'ilks', [vaultId])
		log.debug({vaultTypeHexCurr, vaultTypeHex})
		while (vaultTypeHexCurr.toString("hex") !== vaultTypeHex.toString("hex") && vaultId !== 0) {
			if (vault !== 0) throw new Error('Vault id and type mismatch.')
			vaultId =  Number((await w3.access(args.block, 'MCD_CDP_MANAGER', 'list', [vaultId])).prev)
			log.debug({vaultId})
			if (vaultId !== 0) {
				vaultTypeHexCurr = await w3.access(args.block, 'MCD_CDP_MANAGER', 'ilks', [vaultId])
				log.debug({vaultTypeHexCurr})
			}
		}
		if (vaultTypeHexCurr !== vaultTypeHex) throw new Error('Vault type not opened yet. Pls open first!')
	}
	return {proxyAddress, fromAddress, vaultId}
}

async function getUrnParams (vaultId, type) {
	const vaultAddr = await w3.access(args.block, 'MCD_CDP_MANAGER', 'urns', [vaultId])

	const vaultTypeHex = w3.web3.eth.abi.encodeParameter('bytes32', '0x' + Buffer.from(type).toString('hex'))
	log.info('VaultTypeHex: ' + vaultTypeHex)
	var urn = await w3.access(args.block, 'MCD_VAT', 'urns', [vaultTypeHex, vaultAddr])
	var daiNormalized = BN(urn.art)
	var lockedCollateral = BN(urn.ink)
	var unlockedCollateral = BN(await w3.access(args.block, 'MCD_VAT', 'gem', [vaultTypeHex, vaultAddr]))
	log.info('Dai(normalized) in vault: ' + daiNormalized.toFixed())
	return {vaultAddr, vaultTypeHex, daiNormalized, lockedCollateral, unlockedCollateral}
}

async function vaultInfo (args) {
	var vaults = []
	var {proxyAddress, fromAddress, vaultId} = await getVaultId(args.from, args.vault, args.type)

	var first = true
	while (first || args.vault !== 0) {
		first = false
		log.info("args.vault: " + typeof args.vault)
		log.info(`vaultId: ${vaultId}`)
		console.log(vaultId)
		if (Number(vaultId) === 0) break

		var {vaultAddr, vaultTypeHex, daiNormalized, lockedCollateral, unlockedCollateral} = await getUrnParams(vaultId, args.type)
		//get current rate from vat contract
		var ilk = await w3.access(args.block, 'MCD_VAT', 'ilks', [vaultTypeHex]) 
		var rate = new BN(ilk.rate)
		var spot = new BN(ilk.spot)
		log.info('Rate of ' + args.type +' : ' + rate.div(10**27).toFixed())

		var spotIlk = await w3.access(args.block, 'MCD_SPOT', 'ilks', [vaultTypeHex])
		const priceFeed = spotIlk.pip
		const liquidationRatio = BN(spotIlk.mat)

		const daiDebt = daiNormalized.times(rate).div(BN(10).pow(18 + 27))

		vaults.push({
			vaultId: BN(vaultId),
			proxyUsed: fromAddress === proxyAddress,
			fromAddr: await w3.getAddress(fromAddress),
			vaultAddr: vaultAddr,
			deposit: lockedCollateral.plus(unlockedCollateral).div(BN(10).pow(18)),
			debt: daiDebt,
			daiToGenerate: spot.times(lockedCollateral.plus(unlockedCollateral)).div(BN(10).pow(27+18)).minus(daiDebt),
			lockedCollateral: lockedCollateral.div(BN(10).pow(18)),
			unlockedCollateral: unlockedCollateral.div(BN(10).pow(18)),
			collateralToWithdraw: lockedCollateral.plus(unlockedCollateral).div(BN(10).pow(18)).minus(daiDebt.div(spot.div(BN(10).pow(27)))),
			liquidationRatio: liquidationRatio.div(BN(10).pow(27)),
			priceFeedAddress: priceFeed,
		})

		vaultId = args.vault !== 0 ? args.vault : (await w3.access(args.block, 'MCD_CDP_MANAGER', 'list', [vaultId])).prev
	}
	return vaults
}

async function dispFlog (args) {
	console.log(await getFlog(args))
}

async function getFlog (args) {

	const logs = await w3.web3.eth.getPastLogs(
		{
			fromBlock: args.from_block,
			toBlock:   args.to_block,
			address: await w3.getAddress(args.contract),
			topics: [
				'0x697efb7800000000000000000000000000000000000000000000000000000000'
			]
		}
	)

	var era
	var log
	var sinB
	var amt = args.amount 
	const rad = new BN('1e45')
	if (!logs || logs.length === 0) {
		console.log('no events')
		process.exit(0)
	} else {
		for (var index = 0; index < logs.length && amt >= 0; index++) {
			log = logs[index]    
			var block  = await w3.web3.eth.getBlock(log.blockNumber)
			era = block.timestamp

			sinB = await w3.access(
						args.block,
						'MCD_VOW',
						'sin',
						[new BN(era).toFixed()],
						null, // args.abi,
						args.from, // args.from,
						null, // args.value,
						null, // args.gaslimit,
						null  // args.gasprice
						)

		const sin = Number(new BN(sinB).div(rad))
		const tab = Number(new BN(log.topics[2]).div(rad).toString())
		amt -= Math.min(sin, tab) 

		if (sin > 0) 
			await w3.access(
				args.block,
				'MCD_VOW',
				'flog',
				[era],
				null,
				args.from,
				0,
				args.gaslimit,
				args.gasprice,
				args.nonce
			)

		const d = new Date(era * 1000)
		const date = dateFormat(d, 'yy-mm-dd HH:MM:ss') 
		console.log(`blk: ${log.blockNumber}, ${date}, amt: ${amt.toFixed(2)}, sin: ${sin.toFixed(2)}, tab: ${tab.toFixed(2)},\ntx: ${log.transactionHash},\nminer: ${block.miner}\n `)
		}
	}
	return ''
}

async function dispFlop () {
	console.log(await getFlop())
}

async function getFlop () {
	return await w3.access(
					args.block,
					'MCD_VOW',
					'flop',
					[],
					null, 					// args.abi,
					args.from, 			// args.from,
					0, 							// args.value,
					args.gaslimit, 	// args.gaslimit,
					args.gasprice,  // args.gasprice
					args.nonce  		// args.nonce
	)
}

async function dispTick (args) {
	console.log(await getTick(args))
}

async function getTick (args) {
	return await w3.access(
					args.block,
					'MCD_FLOP',
					'tick',
					[args.id],
					null, 					// args.abi,
					args.from, 			// args.from,
					0, 							// args.value,
					args.gaslimit, 	// args.gaslimit,
					args.gasprice,  // args.gasprice
					args.nonce      // args.nonce
	)
}

async function dispDent (args) {
	console.log(await getDent(args))
}

async function getDent (args) {
	var lot
	var beg
	if (!args.amount) {
	const bids = await w3.access(
					args.block,
					'MCD_FLOP',
					'bids',
					[
						args.id
					],
					null,
					args.from)

		log.info(bids)
		lot = bids.lot
		beg = Number(new BN(await w3.access(args.block, 'MCD_FLOP', 'beg', [])).div(10**18))

		var Bignumber = BN.clone({ 
			DECIMAL_PLACES: 0,
			ROUNDING_MODE: 0})

		lot = new Bignumber(lot).times(10**18).div(beg)
	} else {
		lot = args.amount
	}
	
	return await w3.access(
					args.block,
					'MCD_FLOP',
					'dent',
					[
					args.id,
					lot,
					new BN(await w3.access(args.block, 'MCD_FLOP', 'bid', [])).toFixed(),
					],
					null, // args.abi,
					args.from, // args.from,
					0, // args.value,
					args.gaslimit,  // args.gaslimit,
					args.gasprice,  // args.gasprice
					args.nonce
	)
}

async function dispDeal (args) {
	console.log(await getDeal(args))
}

async function getDeal (args) {
	return await w3.access(
					args.block,
					'MCD_flop',
					'deal',
					[args.id],
					null, // args.abi,
					args.from, // args.from,
					0, // args.value,
					args.gaslimit, // args.gaslimit,
					args.gasprice  // args.gasprice
	)
}

async function dispEthTransaction (args) {
	if (args._[1] === 'source') {
		console.log(await w3.getSourceCode(args.contractName))
		return
	}
	let disp = await getEthTransaction(args)
	var decimals = 0
	if ((await w3.getAddressType(args.contract)).type === 'token' &&
		['balanceOf', 'totalSupply', 'allowance'].includes(args.func)) {
		decimals = await w3.decimals(args.block, args.contract)
	}
		
	if (disp && disp.map) {
		await Promise.all(disp.map(async (func) => console.log(
			func.match && func.match(/^0x[A-Fa-f0-9]{40}$/i) ?
			await w3.getAddressName(func) :
			await toDec(func))))
	} else {
		if (disp !== null || typeof disp !== 'undefined' || disp === '') {
			if (typeof disp === 'object') {
				log.info(`Result is an object: ${JSON.stringify(disp)}`)
				try {
					disp = JSON.stringify(disp)
				} catch (e) {
					disp = util.inspect(disp, {maxArrayLength: null, depth:null})
				}
			} else {
				log.info(`Result is a string: ${disp}`)
				disp = String(disp)
			}

			disp = (await Promise.all(
				disp.split && disp.split(/\n/)
				.map(
					async (line) => 
					line.match(/^0x[A-Fa-f0-9]{40}$/i) && !args.contr  ?
					await w3.getAddressName(line) :
					await toDec(line, decimals))
			)).join("\n")

			console.log(disp)
		}
	}
	return
}

async function toDec (str, decimals) {
	if (typeof decimals === 'undefined' || decimals === null || decimals === "0x") decimals = 0
	log.debug(`decimals: ${decimals}`)
	if (String(str).match(/^[-+]?[0-9]+$/) && (decimals > 0 || BN(str).gt(BN(10).pow(18)))) {
		if (decimals === 0) { 
			decimals = 18
		}
		// return BN(str).div(BN(10).pow(decimals || 18)).toFixed()
		str.padStart(decimals + 1, '0')
		return str.slice(0, -(decimals)) +
			'.' +
			'000000000000000000000000000000000000'.slice(0, Math.max(decimals - str.length, 0)) +
			str.slice(-decimals)	
	} else {
		return str
	}
}

async function calcValue (from, balanceExpr) {
	var balance = BN(await w3.access(args.block, 'ETH', 'balanceOf', from)).div(BN(10).pow(18)).toFixed()
	return ut.evalExpr('max', balance, balanceExpr, true)
}

async function getWeb3 (args) {
	if (Number.isInteger(args.block)) {
		w3.web3.eth.defaultBlock = w3.toHex(args.block)
	}
  args.function = web3MatchingCommands(args.function, true, true)[0]
	var fn = await w3.getWeb3Function(args.function)
	var parent = await w3.getWeb3Function(args.function.replace(/\.\w*\s*$/, ""))

	var params = await Promise.all(args.parameters.map(async param => {

		if (typeof param === 'string' && param.match(/^\s*[[{].*[\]}]\s*$/)) {
			param = JSON.parse(param)	
		}	


		try {
			return await w3.getAddress(param)
		} catch (e)  {
			return param
		}
	}))

	switch (typeof fn) {
		case 'function':
			log.debug("Function has been called.")
			try {
						ret = await fn(...params)
						log.debug("Used the fn(...params) method.")
				return ret
			} catch (e) {
				switch (e.name) {
					case "TypeError":
						var ret = await fn.call(parent, ...params)
						log.debug("Used the fn.call(parent, ...params) method.")
						return ret
					default:
						throw e
				}
			}
		default:
			log.debug("Return object.")
			return fn
	}
}

async function getEthTransaction (args) {
	
	if (args.block < 0) {
		args.block = await w3.web3.eth.getBlockNumber() + args.block
	}

	if (args._[1] === 'web3') {
		return await getWeb3(args)
	}

	if (args._[1] === 'import') {
		return await w3.importAddress(args)
	}

	if (args._[1] === 'address') {
		if (args.contr.match(/^0x[A-Fa-f0-9]{40}$/i)) {
			return await w3.getAddressName(args.contr)
		} else {
			return await w3.getAddress(args.contr)
		}
	}	
	
	if (args._[1] === 'send') {
		const tx = JSON.parse(args.txjson)
		return await w3.broadcastTx(
			tx.from,
			tx.to,
			tx.data,
			tx.value,
			tx.gasLimit,
			tx.gasPrice,
			tx.nonce,
			args.signature
		)
	}

	if (args._[1] === 'nonce') {
		var acc = args.account.match(/^0x[0-9a-fA-F]{40}$/) ? args.account : await w3.getAddress(args.account)
		return await w3.getNonce(acc)
	}

	if (args.ls || args.ls === '' || args._[1] === 'abi') {
		
		args.ls = (!args.ls || args.ls === '') ? '.*' : args.ls
		return await w3.getAbiFunctions(args.abi || args.contract, args.ls)
	
	}

	if (args.contract === 'ETH' || args.contract.match(/0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee/i)) {
		
		log.debug('eth transfer')
		log.debug(`args.func: ${args.func}`)
		log.debug(`args.args: ${JSON.stringify(args.args)}`)

		if (args.func.match(/transfer/i) && args.args[1].match(/max/i)) {
			
			log.debug('eth transfer')
			args.args[1] = await calcValue(args.from, args.args[1])
			log.debug(`value to send: ${args.args[1]}`)
		
		} else if (args.func.match(/^transferFrom$/i) && args.args[2].match(/max/i)) {
		
			log.debug('eth transferFrom')
			args.args[2] = await calcValue(args.args[0], args.args[2])
			log.debug(`value to send: ${args.args[2]}`)
		}
	}

	//handle array arguments
  if (typeof args.args !== 'object') {
    args.args = [args.args]
  }

	args.args = args.args.map(
		arg => arg.match(/^\s*\[.*]\s*$/) ?
		Array.from(JSON.parse(arg)) :
		arg 
	)

	log.debug('args.args: ' + JSON.stringify(args.args))

	return await w3.access(
		args.block,
		args.contract,
		args.func,
		args.args,
		args.abi,
		args.from,
		args.value,
		args.gaslimit,
		args.gasprice,
		args.nonce,
		null, // inputs
		null, // multiple use
		args.calldata
	)
}

// TODO: implement background order creation
async function startProc (args) {
	const connect = promisify(pm2.connect)
	const start = promisify(pm2.start)
	// eslint-disable-next-line
	const stop = promisify(pm2.stop)
	const list = promisify(pm2.list)
	// eslint-disable-next-line
	const readFile = promisify(fs.readFile)
	// eslint-disable-next-line
	const writeFile = promisify(fs.writeFile)
	await connect()

	var procName = path.basename(__filename) + '-' + args._[0]
	const listPm2 = await list()
	while (listPm2.findIndex(desc => desc.name === procName) !== -1) {
		procName += 'I'
	}

	const proc = await start({
		script: procName,
		options: {
			name: procName,
			args: ['--pm2'].concat(process.argv),
		},

	})

	pm2.disconnect()
	return proc
}

// TODO: implement background order creation
// eslint-disable-next-line
async function startFork (exchange, args) {
process.env.pm_id
}

async function dispAddTrickleOrder (exchange, args) {
  var order
  var totalAmount = args.amount
  var sleepMs
  const market = exchange && exchange.markets && exchange.markets[args.pair]
  while (totalAmount > 0) {

    log.info(`Current total amount: ${totalAmount}`)
    args.amount = Math.min(args.batchSize + (args.batchSizeVariance ? args.batchSizeVariance : 0) * (1 - Math.random()), totalAmount)

    args.amount = decimalToPrecision(
      args.amount,
      TRUNCATE,
      args.aPrecision || (market && market.precision.amount) || 5,
      exchange && exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    )

    log.info(`Current order amount: ${args.amount}`)
    try {
      order = await addOrder(exchange, args)
      log.info(order.id)
      if (order.id !== 'skipped-order') {
        totalAmount -= args.amount
      }
    } catch (e) {
      log.error(e)
    }
    if (order.id === 'skipped-order') {
      sleepMs = args.batchRetrySec * 1000
    } else {

    sleepMs = Math.floor(1000 * 
				(
					args.batchTime +
					(
						args.batchTimeVariance 
						? 
							args.batchTimeVariance
						: 0
					) * 
					(
						1 -
						Math.random()
					)
				)
			)
		}
    log.info(`Sleep ${sleepMs / 1000} seconds.`)
    await sleep(sleepMs)
  }
}

function sleep (ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

async function dispOrderbook (exchange, args) {
  const orderbook = await getOrderbook(exchange, args)
  let cumulativeSum = 0
  const market = exchange.markets[args.pair]
  const asks = orderbook.asks
  const bids = orderbook.bids
  var priceCurrency = 1
  if (args.currency) {
    priceCurrency = await getPriceInOtherCurrency(
      args.otherExchange,
      args.pair.replace(/.*\//, ''),
      args.currency
    )
  }
  if (args.limit && args.limit < asks.length) asks.length = args.limit
  if (args.limit && args.limit < bids.length) bids.length = args.limit

  var orderColumns = [{price: '---', amount: '---', cumsum: '---'}]

  orderColumns = orderColumns.concat(asks.map(order => [
    decimalToPrecision(
      order[0] * priceCurrency,
      TRUNCATE,
      args.pPrecision || market.precision.price || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      cumulativeSum += order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
  ])
    .reverse()
    .map(order => { return {price: order[0], amount: order[1], cumsum: order[2]} }))

  orderColumns.push({price: '---', amount: '---', cumsum: '---'})
  cumulativeSum = 0

  orderColumns = orderColumns.concat(bids.map(order => [
    decimalToPrecision(
      order[0] * priceCurrency,
      TRUNCATE,
      args.pPrecision || market.precision.price || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
    decimalToPrecision(
      cumulativeSum += order[1],
      TRUNCATE,
      args.aPrecision || market.precision.amount || 5,
      exchange.id === 'bitfinex' ? SIGNIFICANT_DIGITS : DECIMAL_PLACES,
      PAD_WITH_ZERO
    ),
  ])
    .map(order => { return {price: order[0], amount: order[1], cumsum: order[2]} }))

  const columns = columnify(orderColumns, {align: 'right'})
  console.log(columns)
}

async function getPriceInOtherCurrency (exchangeName, baseToken, quoteToken) {
  const exchange1 = ut.getExchange(exchangeName)
  const orderbook = await getOrderbook(exchange1, {limit: 5, pair: baseToken + '/' + quoteToken})
  return orderbook.asks[0][0]
}

async function getOrderbook (exchange, args) {
  const limit = args.limit ? args.limit : undefined
  return await exchange.fetchOrderBook(args.pair, limit)
}

async function dispMarkets (exchange, args) {
  console.dir(JSON.stringify(await getMarkets(exchange, args)))
}

async function getMarkets (exchange) {
  return await exchange.loadMarkets()
}

async function removeAllOrders (exchange, args) {
  const orders = await listOrders(exchange, args)
  orders.map(async (order) => await removeOrder(exchange, {order: order.id, symbol: order.symbol}))
  return
}

async function removeOrder (exchange, args) {
  var symbol
  if (typeof args.symbol !== 'undefined') {
    symbol = args.symbol
  } else { 
    const orders = await listOrders(exchange, args)
    const order = orders.find(order => order.id === args.order)
    if (typeof order !== 'undefined') {
      symbol = order['symbol']
    } else {
      throw new Error('Order id ' + args.order + ' does not exist.')
    }
  }
  console.log(args.order, symbol)
  return await exchange.cancelOrder(String(args.order), String(symbol), [])
}

async function dispAddOrder (exchange, args) {
  const order = await addOrder(exchange, args)
  console.log(order.id)
}

async function addOrder (exchange, args) {
  if ((typeof exchange !== 'undefined') && exchange.id === 'okex') {
    exchange.options['createMarketBuyOrderRequiresPrice'] = false
	}
  var amount = args.amount
  const buy = args.side === 'buy'

  // disregard price data if args.type is market
  var price = args.type === 'market' ? undefined : args.price
  args.price = price

  if (!Object.keys(config.get('keys')).includes(args.exchange)) {
    throw new Error('Exchange "' + args.exchange + '" not found in config ./config/default.yaml.')
  }
  const exchangeType = config.get(`keys.${args.exchange}.type`)
  switch (exchangeType) {
    case 'centralized':
      return await addOrderCentralized(exchange, args, amount, buy, price)
    case 'kyber':
      return await addOrderKyber(args, amount, buy, price)
    case 'uniswap':
      return await addOrderUniswap(args, amount, buy, price)
  }
}

async function addOrderUniswap (args, amount, buy) {

  if (args.type === 'limit') {
    throw new Error(`Limit orders not supported (yet).`)
  }
  const sellToken = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
  log.info(`Sell token: ${sellToken}`)

  const buyToken = buy ? args.pair.replace(/\/.*/, '') : args.pair.replace(/.*\//, '')
  log.info(`Buy token: ${buyToken}`)

  const sellDecimals = await w3.decimals(args.block, sellToken)
  log.info(`${sellToken} decimals: ${sellDecimals}`)

  const buyDecimals = await w3.decimals(args.block, buyToken)
  log.info(`${buyToken} decimals: ${buyDecimals}`)

	const fromAddress = await w3.getAddress(args.from || config.get('web3.defaultFrom'))
	log.info(`tx from: ${fromAddress}`)

	args.path = await w3.getPath(sellToken, buyToken, args.path)

	var sellAmt
	var buyAmt

	var balance = BN(
		await w3.access(
			args.block,
			sellToken,
			'balanceOf',
			fromAddress,
			null, // abi - not necessary
			args.from,
		)
	)
		
	if (amount.match(/max/i)) {

    log.info(`${sellToken} balance: ${balance.div(10 ** sellDecimals).toFixed()}`)

    sellAmt = new BN(ut.evalExpr('max', balance.toFixed(), amount, true)).decimalPlaces(0)

		buyAmt = new BN(
			(await w3.access(
				args.block,
				'UNISWAP_ROUTER_V2',
				'getAmountsOut',
				[	
					sellAmt.toFixed(),
					Array.from(JSON.parse(args.path)),
				],
				null,  //abi name
				args.from,
			)
		).slice(-1)[0]
		)

    log.info(`Uniswap final amount: ${sellAmt.toString()}`)
  } else {
		const tokenAmt = BN(amount).times(10 ** (buy ? Number(buyDecimals) : Number(sellDecimals))).decimalPlaces(0)
    
		if (buy) {
			sellAmt = BN(
				(
					await w3.access(
						args.block,
						'UNISWAP_ROUTER_V2',
						'getAmountsIn',
						[	
							tokenAmt.toFixed(),
							Array.from(JSON.parse(args.path)),
						],
						null,  //abi name
						args.from,
					)
				)[0])

			buyAmt = tokenAmt
		} else {
			sellAmt = tokenAmt

			buyAmt = BN(
				(
					await w3.access(
						args.block,
						'UNISWAP_ROUTER_V2',
						'getAmountsOut',
						[	
							sellAmt.toFixed(),
							Array.from(JSON.parse(args.path)),
						],
						null,  //abi name
						args.from,
					)
				).slice(-1)[0]
			)
		}
  }
	
  const dueTimestampSec = BN((new Date(chrono.parseDate(args.dueTime))).getTime()).div(1000).decimalPlaces(0).toFixed()

	var uniswapFunction = `swap\
		${buy ? '' : 'Exact'}\
    ${sellToken === 'ETH' ? 'ETH' : 'Tokens'}\
		For\
		${buy ? 'Exact' : ''}\
		${buyToken === 'ETH' ? 'ETH' : 'Tokens'}\
		${buy ? '' : 'SupportingFeeOnTransferTokens'}`.replace(/\s*/g, '')

	const minBuyAmount = buyAmt.times((100. - args.minPercent)/100.).decimalPlaces(0)
	const maxSellAmount = BN.min(balance, sellAmt.times((100. + args.minPercent)/100.).decimalPlaces(0))
	const ethValue = sellToken === 'ETH' ? maxSellAmount.toFixed() : null

	log.debug(JSON.stringify({
		ethValue,
		buyToken,
		buyAmt,
		minBuyAmount,
	}))

	log.debug(JSON.stringify({
		sellToken,
		sellAmt,
		maxSellAmount,
		dueTimestampSec,
	}))

	var uniswapArgs = 
		[
			buy ? buyAmt.toFixed() : sellAmt.toFixed(),
			buy ? maxSellAmount.toFixed() : minBuyAmount.toFixed(),
			Array.from(JSON.parse(args.path)),
			args.to || args.from,
			dueTimestampSec
		]

	if (sellToken === 'ETH') {
		// remove first element of args
		uniswapArgs.shift()
		uniswapArgs[0] = minBuyAmount.toFixed()
	}

  const a = [
		'UNISWAP_ROUTER_V2',
		uniswapFunction,
		uniswapArgs,
		null,  //abi name
		args.from,
		ethValue,
		args.gaslimit,
		args.gasprice,
		args.nonce
	]

	log.debug(`w3.access(args.block, ${JSON.stringify(a.slice(0, 2))}...`)
	log.debug(`...${JSON.stringify(a.slice(2))})`)

  const priceToken = 
		buy 
		? 
      sellAmt.div(BN(10).pow(BN(sellDecimals))).div(buyAmt.div(BN(10).pow(BN(buyDecimals))))
    :
      buyAmt.div(BN(10).pow(BN(buyDecimals)))
      .div(sellAmt.div(BN(10).pow(BN(sellDecimals))))

	const priceDisp = priceToken.toFixed(6)
  const tokensDisp = buy ? buyToken+'/'+sellToken : sellToken + '/' + buyToken
  const buyDisp = buyAmt.div(BN(10).pow(BN(buyDecimals))).toFixed(6)
	var render = []
	if (/max/.test(amount)) {
		const sellDisp = sellAmt.div(BN(10).pow(BN(sellDecimals))).toFixed(6)

		render.push({
			action: 'sell',
			amount: sellDisp,
			token: sellToken
		})
	}

		render.push({
			action: 'price',
			amount: priceDisp,
			token: tokensDisp,
		})

		render.push({
			action: 'receive',
			amount: buyDisp,
			token: buyToken,
		})

	var display = columnify(render,
    {config: {
      amount: {align: 'right'},
		}})

  console.log(display)
	const accType = `web3.account.${await w3.getAddressName(args.from)}.type`
	if (config.has(accType)) {
		if (config.get(accType) !== 'privatekey') {
			await pressAnyKey('Press any key to continue!')
		}
	} else {
		throw new Error('From address must be stored in ./config/secrets/default.yaml -> web3: -> account:')
	}

	const allowance = BN(await w3.access(args.block, sellToken, 'allowance', [args.from, 'UNISWAP_ROUTER_V2']))
	if (allowance.lt(sellAmt)) {
		await w3.access(
			args.block,
			sellToken,
			'approve',
			['UNISWAP_ROUTER_V2', BN(2).pow(256).minus(1).toFixed()],
			null,
			args.from,
			0,
			args.gaslimit,
			args.gasprice,
			args.nonce
		)
	}
	
	if (args._[1] !== 'trickle' ||
		( buy && priceToken.lt(args.batchMinRate)) ||
		(!buy && priceToken.gt(args.batchMinRate))) {

		log.debug(`Final params:`, {a})
		
		const receipt = await w3.access(args.block, ...a, null, args._[1] === 'trickle')
		
    if (!receipt.status) {
      log.error(`Transaction reverted`)
      log.debug(`Receipt: ${JSON.stringify(receipt)}`)
			return {id: 'skipped-order'}
    }
    return {id: 'no-order-id'}
	} else {
		log.warn(`Order skipped because Uniswap rate ${priceDisp} ${buy ? 'greater' : 'less'} than allowed rate ${args.batchMinRate}.`)
    return {id: 'skipped-order'}
	}
}

async function addOrderKyber (args, amount, buy) {

  if (args.type === 'limit') {
    log.error(`Limit orders not supported (yet).`)
    process.exit(1)
  }

  const sellToken = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
  log.info(`Sell token: ${sellToken}`)

  const buyToken = buy ? args.pair.replace(/\/.*/, '') : args.pair.replace(/.*\//, '')
  log.info(`Buy token: ${buyToken}`)

  const sellDecimals = await w3.decimals(args.block, sellToken)
  log.info(`${sellToken} decimals: ${sellDecimals}`)

  const buyDecimals = await w3.decimals(args.block, buyToken)
  log.info(`${buyToken} decimals: ${buyDecimals}`)

  var buyTokenCap
  try {
    buyTokenCap = new BN(await w3.access(
      args.block,
      'KyberNetworkProxy',
      'getUserCapInTokenWei',
      [
        config.get('web3.defaultFrom'),
        buyToken
      ]
    ))
  } catch (e) {
    buyTokenCap = new BN(w3.MAX_DEST_AMOUNT)
  }
  log.info(`Kyber ${buyToken} cap: ${buyTokenCap.div(10 ** buyDecimals).toString()}`)


  if (amount.match(/max/i)) {
    if (sellToken === 'ETH') {
      var balance = new BN(await w3.web3.eth.getBalance(await w3.getAddress(config.get('web3.defaultFrom'))))
    } else {
      balance = new BN(await w3.access(
        args.block,
        sellToken,
        'balanceOf',
        config.get('web3.defaultFrom'),
        'ERC20'
      ))
    }
    log.info(`Balance: ${balance.div(10 ** sellDecimals).toString()}`)

    let {expectedRate: kyberRate} = await w3.access(
      args.block,
      'KyberNetworkProxy',
      'getExpectedRate',
      [
        sellToken,
        buyToken,
        balance.toString(),
      ]
    )

    kyberRate = new BN(kyberRate)
    log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

    const maxSellAmt = ut.minBN(
      balance,
      buyTokenCap
      .times(10 ** sellDecimals) // decimals of sellToken
      .times(10 ** 18) // decimals of kyberRate
      .div(10 ** buyDecimals)  // decimals of buyToken
      .div(kyberRate),
    )

    log.info(`Kyber maxSellAmt: ${maxSellAmt.div(10 ** sellDecimals).toString()}`)

    var amt = new BN(ut.evalExpr('max', maxSellAmt.toString(), amount, true))
    log.info(`Kyber final amount: ${amt.toString()}`)
  } else {
    amount = new BN(amount)

    let {expectedRate: kyberRate} = await w3.access(
      args.block,
      'KyberNetworkProxy',
      'getExpectedRate',
      [
        sellToken,
        buyToken,
        '1000000000000000000',
      ])

    kyberRate = new BN(kyberRate)
    // log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

    if (kyberRate.toString() === '0') {
      log.error(`There is no liquidiy on Kyber.`)
      process.exit(1)
    }

    var sellTokenAmt = buy ? amount
      .times(10 ** buyDecimals)
      .times(10 ** 18)
      .div(kyberRate)
      .decimalPlaces(0)
      : amount
      .times(10 ** sellDecimals)
      .decimalPlaces(0)

    log.info(`Kyber sell token amount: ${sellTokenAmt.toString()}`)

    if (buy) { // iterate another to find a close enough sellTokenAmt
      let {'expectedRate': kyberRate} = await w3.access(
        args.block,
        'KyberNetworkProxy',
        'getExpectedRate',
        [
          sellToken,
          buyToken,
          sellTokenAmt.toString(),
        ]
      )

      kyberRate = new BN(kyberRate)
      log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)

      sellTokenAmt = amount
        .times(10 ** buyDecimals)
        .times(10 ** 18)
        .div(kyberRate)
        .decimalPlaces(0)

      log.info(`Kyber amount: ${sellTokenAmt.toString()}`)
    }

    if (buyTokenCap.lt(sellTokenAmt.times(kyberRate))) {
      log.error(`Sell amount (${sellTokenAmt.times(kyberRate).toString()}) exceeds user cap (${buyTokenCap})`)
      throw new Error('Sell amount exceeds user cap')
    }
    amt = sellTokenAmt
  }

  let {expectedRate: kyberRate} = await w3.access(
    args.block,
    'KyberNetworkProxy',
    'getExpectedRate',
    [
      sellToken,
      buyToken,
      amt.toString(),
    ])

  kyberRate = new BN(kyberRate)
  log.info(`Kyber rate: ${kyberRate.div(10 ** 18).toString()}`)
  if (kyberRate.div(10 ** 18).gt(new BN(args.batchMinRate))) {
    const receipt = await w3.kyberTrade(
      config.get('web3.defaultFrom'),
      sellToken,
      amt.toString(),
      buyToken,
      config.get('web3.defaultFrom'),
      w3.MAX_DEST_AMOUNT,
      '0',
      '0x0000000000000000000000000000000000000000',
			args.gaslimit,
			args.gasprice,
			args.nonce
    )

    if (!receipt.status) {
      log.error(`Transaction reverted`)
      log.debug(`Receipt: ${JSON.stringify(receipt)}`)
      process.exit(1)
    }
    return {id: 'no-order-id'}
  } else {
    log.warn(`Order skipped because kyber rate ${kyberRate.div(10 ** 18).toString()} less than current min rate ${args.batchMinRate}.`)
    return {id: 'skipped-order'}
  }
}

async function addOrderCentralized (exchange, args, amount, buy, price) {
	const quoteToken = args.pair.replace(/.*\//, '')
	const baseToken = args.pair.replace(/\/.*/, '')
	const currPrice = await getPriceInOtherCurrency (args.exchange, baseToken, quoteToken)
	log.debug(`currPrice: ${currPrice}`)
	if (args.batchMinRate) {
		if ((buy && currPrice > args.batchMinRate) || (!buy && currPrice < args.batchMinRate)) {
			return {id: 'skipped-order'}
		}
	}
  if (amount.match(/max/i)) {
    const token = buy ? args.pair.replace(/.*\//, '') : args.pair.replace(/\/.*/, '')
    const dust = config.get('dust-limit')
    const tokenAmount = (await listBalances(exchange, {token, dust}, {type: 'free'}))[token]
		log.debug(`tokenAmount: ${tokenAmount}`)
    if (args.type === 'limit') {
      var finalAmount = buy ? tokenAmount / args.price : tokenAmount
    } else {
      finalAmount = buy ? await getSpendAmountFromOrderbook(exchange, tokenAmount) : tokenAmount
    }
		log.debug(`finalAmount: ${finalAmount}`)
    amount = ut.evalExpr('max', finalAmount, amount)
  } else await exchange.loadMarkets()

  const market = exchange.markets[args.pair]

  log.debug('amount: ' + amount)
  if (args.type === 'market' && !exchange.has['createMarketOrder']) {
    const type = 'limit'
		
    const maxPrice = market['max'] && market['max']['price'] ?
      market['max']['price'] :
      1000000

		log.debug(`market maxPrice ${maxPrice}`)

    const minPrice = market['min'] && market['min']['price'] ?
      market['min']['price'] :
      0

		log.debug(`market minPrice ${minPrice}`)

    price = buy ? maxPrice : minPrice
    const {price: finalPrice, amount: finalAmount} = await fitPriceAndAmountToMarket(exchange, price, amount)
    return await exchange.createOrder(args.pair, type, args.side, finalAmount, finalPrice, args.params)
  } else {
    const {price: finalPrice, amount: finalAmount} = await fitPriceAndAmountToMarket(exchange, price, amount)
		log.debug(`finalPrice ${finalPrice} finalAmount ${finalAmount}`)
    return await exchange.createOrder(args.pair, args.type, args.side, finalAmount, finalPrice, args.params)
  }
}

async function fitPriceAndAmountToMarket (exchange, price, amount) {
  const market = exchange.markets[args.pair]
  
	const minAmount = market['min'] && market['min']['amount'] ? market['min']['amount'] : 0
  const maxAmount = market['max'] && market['max']['amount'] ? market['max']['amount'] : 1000000
	log.debug(`market minAmount: ${minAmount}`)	
	log.debug(`market maxAmount: ${maxAmount}`)	

	log.debug(`amount before check min max: ${amount}`)
  if (amount < minAmount) amount = minAmount
  if (amount > maxAmount) amount = maxAmount
	log.debug(`amount after  check min max: ${amount}`)

	log.debug(`amount before truncate: ${amount}`)
	log.debug(`amount precision: ${market.precision.amount}`)

	log.debug(`\
	sigdig ${SIGNIFICANT_DIGITS}\
	decpl: ${DECIMAL_PLACES}\
	final: ${exchange.id.match(/bitfinex|okex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES}\
	exchangeid: ${exchange.id}`)

	log.debug(`precision reported by market:${market.precision.amount}`)
  if (market.precision.amount !== 0) {	
		amount = decimalToPrecision(
			amount,
			TRUNCATE,
			//some exchanges report precision 
			market.precision.amount < 1 ? market.precision.amount.toString().split('.')[1].length || 0 : market.precision.amount,
			exchange.id.match(/bitfinex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES
		)
	}
	log.debug(`amount after truncate: ${amount}`)
	
	log.debug(`price before adust: ${price}`)
  if (price) {
    const maxPrice = market['max'] ?
      market['max']['price'] :
      1000000

    const minPrice = market['min'] ?
      market['min']['price'] :
      0

    price = price < minPrice ? minPrice : price
    price = price > maxPrice ? maxPrice : price
    if (
      market['max'] &&
      market['max']['cost'] &&
      amount * price > market['max']['cost']
    ) {
      price = market['max']['cost'] / amount
    }

    if (
      market['min'] &&
      market['min']['cost'] &&
      amount * price < market['min']['cost']
    ) {
      price = market['max']['cost'] / amount
    }
		log.debug(`price before adust: ${price}`)

		log.debug(`price before truncate: ${price}`)
		log.debug(`price precision: ${market.precision.price}`)

		log.debug(`\\
		sigdig ${SIGNIFICANT_DIGITS} decpl: ${DECIMAL_PLACES}\\
		final: ${exchange.id.match(/bitfinex|okex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES}\\
		exchangeid: ${exchange.id}`)

		price = decimalToPrecision(
      price,
      TRUNCATE,
			market.precision.price < 1 ? market.precision.price.toString().split('.')[1].length || 0 : market.precision.price,
      exchange.id.match(/bitfinex/) ? SIGNIFICANT_DIGITS : DECIMAL_PLACES
    )

		log.debug(`price after truncate: ${price}`)

  }
  return {price, amount}
}

async function getSpendAmountFromOrderbook (exchange, tokenAmount) {
  const orderbook = await getOrderbook(exchange, args)
  var amountToSpend = tokenAmount
  var orderNum = 0
  var finalAmount = 0
  while (amountToSpend > 0 && orderNum < orderbook.asks.length) {
    const sellPrice = orderbook.asks[orderNum][0]
    const sellAmount = orderbook.asks[orderNum][1]
    if (amountToSpend > sellPrice * sellAmount) {
      finalAmount += sellAmount
      amountToSpend -= sellPrice * sellAmount
    } else {
      finalAmount += amountToSpend / sellPrice
      amountToSpend = 0
    }
    orderNum++
  }
  return finalAmount
}

async function lockedAmount (exchange, token) {
  const orders = await listOrders(exchange, {pair: undefined, since: undefined, limit: undefined})
  const pairBuy = new RegExp('.*/' + token)
  const pairSell = new RegExp(token + '/.*')
  return orders.filter(
    order => order.side === 'buy' && order.symbol.match(pairBuy) ||
    order.side === 'sell' && order.symbol.match(pairSell)
  )
    .map(order => order.side === 'buy' ? order.remaining * order.price : order.remaining)
    .reduce((total, remaining) => total + remaining, 0)
}

async function dispListOrders (exchange, args) {
  const orders = await listOrders(exchange, args)
  orders.map(order => console.log(order.id + ' ' + order.type + ' ' + order.side + ' ' + order.amount + ' ' + order.symbol + ' ' + order.price))
}

async function listOrders (exchange, args) {
  if (exchange.id === 'binance') {
    exchange.options['warnOnFetchOpenOrdersWithoutSymbol'] = false
    console.log('Rate limit: Do not start this in 271 secs to avoid ban.')
  }
  const fetchOrders = args.closed ? exchange.fetchClosedOrders.bind(exchange) : exchange.fetchOpenOrders.bind(exchange)
  args.closed && exchange.loadMarkets()
  if (!args.closed && exchange.has['fetchOpenOrders'] ||
    args.closed && exchange.has['fetchClosedOrders']) {
    return await fetchOrders(args.pair, args.since, args.limit)
  } else {
    throw new Error('Exchange does not support fetching open offers.')
  }
}

async function dispDeposit (exchange, args) {
  console.log(await deposit(exchange, args))
}

async function deposit (exchange, args) {
  const deposit = await exchange.fetchDepositAddress(args.token)
  return deposit.address
}

async function withdraw (exchange, args) {
  var amt = args.amount
  if (amt.match(/max/i)) {

    // security check

    args.dust = config.get('dust-limit')
    const balances = await listBalances(exchange, args)
    const balanceValue = balances[args.token]
    const lockedValue = await lockedAmount(exchange, args.token)
    amt = ut.evalExpr('max', balanceValue - lockedValue, amt)

    amt = decimalToPrecision(
      amt,
      TRUNCATE,
      args.digits,
      DECIMAL_PLACES
    )
  }

  log.debug('amount:', amt)
  const confStart = 'withdraw.' + args.exchange
  var confToken = confStart + '.' + args.token
  if (!config.has(confToken)) {
    confToken = confStart + '.default'
    if (!config.has(confToken)) {
      throw new Error('Withdrawal for token ' + args.token + ' not defined in config.')
    }
  }
  const confDestPart = confToken + '.' + args.destination
  const confDestination = confDestPart + '.destination'
  const confTag = confDestPart + '.tag'
  const confParams = confDestPart + '.params'
  var tag
  if (config.has(confTag)) tag = config.get(confTag)
  const address = config.get(confDestination)
  const params = config.get(confParams)
  await exchange.withdraw(args.token, amt, address, tag, params)
}

async function dispListBalances (exchange, args, params) {
  const balances = await listBalances(exchange, args, params)
  Object.keys(balances).map(currency => console.log(currency + ' ' + balances[currency]))
}

async function listBalances (exchange, args, params = {}) {
	var filtered
  var balances = await exchange.fetchBalance(params)
	const balanceType = (params && params.type) || 'total'
  var balance = balances[balanceType]
	log.debug(`balance from ccxt: ${JSON.stringify(balance)}`)
	log.debug(`typeof balance: ${typeof balance}`)
	if (typeof balance === 'undefined' || JSON.stringify(balance) === '{}') { 
		log.warn(`balance is not useable`)

		//log.debug(`balances: ${JSON.stringify(balances)}`)
		balances = balances.info.balances &&
			balances.info.balances.reduce(
				(entry, asset) => {
					entry = {
						...entry,
						[asset.asset]:{
							free: Number(asset.free),
							locked: Number(asset.locked),
							total: Number(asset.locked) + Number(asset.free)
						},
					
						total: {
							...entry.total,
							[asset.asset]: Number(asset.locked) + Number(asset.free)
						},

						free: {
							...entry.free,
							[asset.asset]: Number(asset.free)
						},
					
						locked: {
							...entry.locked,
							[asset.asset]: Number(asset.locked)
						}
					}

					return entry
				},
			{})
 
		//log.debug(`balances: ${JSON.stringify(balances)}`)
		balance = balances[balanceType]
	}

	log.debug(JSON.stringify(balance))
	log.debug(`args.token: ${args.token}`)
	if (typeof balance !== 'undefined') { 
    filtered = Object
    .keys(balance)
    .filter(currency => balance[currency] >= args.dust && (!args.token || args.token === currency))
    .reduce((bal, currency) => { bal[currency] = balance[currency]; return bal }, {})
	} else {
		if (params.type === 'free') {
			balance = balances['total']

			filtered = Object
				.keys(balance)
				.filter(currency => balance[currency] >= args.dust && (!args.token || args.token === currency))

			filtered = await filtered
				.reduce(async (bal, currency) => { bal[currency] = balance[currency] - await lockedAmount(exchange, currency); return bal }, {})
		}
	}
  return filtered
}


module.exports = {
	aaveBorrow, 					// tested
	aaveCollateral,				// tested
	aaveDeposit,					// tested
	aaveEstimate,
	aaveInfo,
	aaveLiquidate,
	aavePayback,
	aaveRebalance,
	aaveSwapRate,
	aaveWithdraw,
	addOrder,
	addOrderCentralized,
	addOrderKyber,
	addOrderUniswap,
	argParse,
	calcValue,
	curveInfo,
	deposit,
	dispAaveBorrow,
	dispAaveCollateral,
	dispAaveDeposit,
	dispAaveEstimate,
	dispAaveInfo,
	dispAaveLiquidate,
	dispAavePayback,
	dispAaveRebalance,
	dispAaveSwapRate,
	dispAaveWithdraw,
	dispAddOrder,
	dispAddTrickleOrder,
	dispCurveInfo,
	dispDeal,
	dispDent,
	dispDeposit,
	dispEthTransaction,
	dispFlog,
	dispFlop,
	dispListBalances,
	dispListOrders,
	dispMarkets,
	dispOrderbook,
	dispTick,
	dispVaultDeposit,
	dispVaultEstimate,
	dispVaultGenerate,
	dispVaultInfo,
	dispVaultOpen,
	dispVaultPayback,
	dispVaultWithdraw,
	estimateGasCost,
	fitPriceAndAmountToMarket,
	getDeal,
	getDent,
	getEthTransaction,
	getFlog,
	getFlop,
	getMarkets,
	getOrderbook,
	getPriceInOtherCurrency,
	getReferralCode,
	getSpendAmountFromOrderbook,
	getTick,
	getUrnParams,
	getVaultId,
	ledgerAddresses,
	listBalances,
	listOrders,
	lockedAmount,
	removeAllOrders,
	removeOrder,
	startFork,
	startProc,
	toDec,
	vaultDeposit,
	vaultEstimate,
	vaultGenerate,
	vaultInfo,
	vaultOpen,
	vaultPayback,
	vaultWithDraw,
	withdraw,
}
